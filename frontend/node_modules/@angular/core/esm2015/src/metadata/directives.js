/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ChangeDetectionStrategy } from '../change_detection/constants';
import { compileComponent as render3CompileComponent, compileDirective as render3CompileDirective } from '../render3/jit/directive';
import { compilePipe as render3CompilePipe } from '../render3/jit/pipe';
import { makeDecorator, makePropDecorator } from '../util/decorators';
import { noop } from '../util/noop';
/**
 * Type of the Directive decorator / constructor function.
 * \@publicApi
 * @record
 */
export function DirectiveDecorator() { }
// WARNING: interface has both a type and a value, skipping emit
const ɵ0 = /**
 * @param {?=} dir
 * @return {?}
 */
(dir = {}) => dir, ɵ1 = /**
 * @param {?} type
 * @param {?} meta
 * @return {?}
 */
(type, meta) => SWITCH_COMPILE_DIRECTIVE(type, meta);
/**
 * Type of the Directive metadata.
 *
 * \@publicApi
 * @type {?}
 */
export const Directive = makeDecorator('Directive', (ɵ0), undefined, undefined, (ɵ1));
/**
 * Component decorator interface
 *
 * \@publicApi
 * @record
 */
export function ComponentDecorator() { }
// WARNING: interface has both a type and a value, skipping emit
const ɵ2 = /**
 * @param {?=} c
 * @return {?}
 */
(c = {}) => (Object.assign({ changeDetection: ChangeDetectionStrategy.Default }, c)), ɵ3 = /**
 * @param {?} type
 * @param {?} meta
 * @return {?}
 */
(type, meta) => SWITCH_COMPILE_COMPONENT(type, meta);
/**
 * Component decorator and metadata.
 *
 * \@Annotation
 * \@publicApi
 * @type {?}
 */
export const Component = makeDecorator('Component', (ɵ2), Directive, undefined, (ɵ3));
/**
 * Type of the Pipe decorator / constructor function.
 *
 * \@publicApi
 * @record
 */
export function PipeDecorator() { }
// WARNING: interface has both a type and a value, skipping emit
const ɵ4 = /**
 * @param {?} p
 * @return {?}
 */
(p) => (Object.assign({ pure: true }, p)), ɵ5 = /**
 * @param {?} type
 * @param {?} meta
 * @return {?}
 */
(type, meta) => SWITCH_COMPILE_PIPE(type, meta);
/**
 * \@Annotation
 * \@publicApi
 * @type {?}
 */
export const Pipe = makeDecorator('Pipe', (ɵ4), undefined, undefined, (ɵ5));
/**
 * \@publicApi
 * @record
 */
export function InputDecorator() { }
// WARNING: interface has both a type and a value, skipping emit
const ɵ6 = /**
 * @param {?=} bindingPropertyName
 * @return {?}
 */
(bindingPropertyName) => ({ bindingPropertyName });
/**
 * \@Annotation
 * \@publicApi
 * @type {?}
 */
export const Input = makePropDecorator('Input', (ɵ6));
/**
 * Type of the Output decorator / constructor function.
 *
 * \@publicApi
 * @record
 */
export function OutputDecorator() { }
// WARNING: interface has both a type and a value, skipping emit
const ɵ7 = /**
 * @param {?=} bindingPropertyName
 * @return {?}
 */
(bindingPropertyName) => ({ bindingPropertyName });
/**
 * \@Annotation
 * \@publicApi
 * @type {?}
 */
export const Output = makePropDecorator('Output', (ɵ7));
/**
 * Type of the HostBinding decorator / constructor function.
 *
 * \@publicApi
 * @record
 */
export function HostBindingDecorator() { }
// WARNING: interface has both a type and a value, skipping emit
const ɵ8 = /**
 * @param {?=} hostPropertyName
 * @return {?}
 */
(hostPropertyName) => ({ hostPropertyName });
/**
 * \@Annotation
 * \@publicApi
 * @type {?}
 */
export const HostBinding = makePropDecorator('HostBinding', (ɵ8));
/**
 * Type of the HostListener decorator / constructor function.
 *
 * \@publicApi
 * @record
 */
export function HostListenerDecorator() { }
// WARNING: interface has both a type and a value, skipping emit
const ɵ9 = /**
 * @param {?=} eventName
 * @param {?=} args
 * @return {?}
 */
(eventName, args) => ({ eventName, args });
/**
 * Decorator that binds a DOM event to a host listener and supplies configuration metadata.
 * Angular invokes the supplied handler method when the host element emits the specified event,
 * and updates the bound element with the result.
 *
 * If the handler method returns false, applies `preventDefault` on the bound element.
 *
 * \@usageNotes
 *
 * The following example declares a directive
 * that attaches a click listener to a button and counts clicks.
 *
 * ```ts
 * \@Directive({selector: 'button[counting]'})
 * class CountClicks {
 *   numberOfClicks = 0;
 *
 * \@HostListener('click', ['$event.target'])
 *   onClick(btn) {
 *     console.log('button', btn, 'number of clicks:', this.numberOfClicks++);
 *  }
 * }
 *
 * \@Component({
 *   selector: 'app',
 *   template: '<button counting>Increment</button>',
 * })
 * class App {}
 * ```
 *
 * \@Annotation
 * \@publicApi
 * @type {?}
 */
export const HostListener = makePropDecorator('HostListener', (ɵ9));
/** @type {?} */
export const SWITCH_COMPILE_COMPONENT__POST_R3__ = render3CompileComponent;
/** @type {?} */
export const SWITCH_COMPILE_DIRECTIVE__POST_R3__ = render3CompileDirective;
/** @type {?} */
export const SWITCH_COMPILE_PIPE__POST_R3__ = render3CompilePipe;
/** @type {?} */
const SWITCH_COMPILE_COMPONENT__PRE_R3__ = noop;
/** @type {?} */
const SWITCH_COMPILE_DIRECTIVE__PRE_R3__ = noop;
/** @type {?} */
const SWITCH_COMPILE_PIPE__PRE_R3__ = noop;
/** @type {?} */
const SWITCH_COMPILE_COMPONENT = SWITCH_COMPILE_COMPONENT__POST_R3__;
/** @type {?} */
const SWITCH_COMPILE_DIRECTIVE = SWITCH_COMPILE_DIRECTIVE__POST_R3__;
/** @type {?} */
const SWITCH_COMPILE_PIPE = SWITCH_COMPILE_PIPE__POST_R3__;
export { ɵ0, ɵ1, ɵ2, ɵ3, ɵ4, ɵ5, ɵ6, ɵ7, ɵ8, ɵ9 };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L1Byb2plY3RzL1Rlc3RQcm9qZWN0L0NoYXJnaW5nL0NoYXJnaW5nL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL2VzbTIwMTUvc3JjL21ldGFkYXRhL2RpcmVjdGl2ZXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpQ0ErTWlDLG1DQUFrQzs7aUNBRWxDLG1DQUFrQzs7NEJBRXZDLDhCQUE2QiIsImZpbGUiOiJkaXJlY3RpdmVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxyXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsY29uc3RhbnRQcm9wZXJ0eSxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXHJcbiAqL1xyXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXHJcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi4vY2hhbmdlX2RldGVjdGlvbi9jb25zdGFudHMnO1xyXG5pbXBvcnQgeyBjb21waWxlQ29tcG9uZW50IGFzIHJlbmRlcjNDb21waWxlQ29tcG9uZW50LCBjb21waWxlRGlyZWN0aXZlIGFzIHJlbmRlcjNDb21waWxlRGlyZWN0aXZlIH0gZnJvbSAnLi4vcmVuZGVyMy9qaXQvZGlyZWN0aXZlJztcclxuaW1wb3J0IHsgY29tcGlsZVBpcGUgYXMgcmVuZGVyM0NvbXBpbGVQaXBlIH0gZnJvbSAnLi4vcmVuZGVyMy9qaXQvcGlwZSc7XHJcbmltcG9ydCB7IG1ha2VEZWNvcmF0b3IsIG1ha2VQcm9wRGVjb3JhdG9yIH0gZnJvbSAnLi4vdXRpbC9kZWNvcmF0b3JzJztcclxuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uL3V0aWwvbm9vcCc7XHJcbi8qKlxyXG4gKiBUeXBlIG9mIHRoZSBEaXJlY3RpdmUgZGVjb3JhdG9yIC8gY29uc3RydWN0b3IgZnVuY3Rpb24uXHJcbiAqIFxcQHB1YmxpY0FwaVxyXG4gKiBAcmVjb3JkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gRGlyZWN0aXZlRGVjb3JhdG9yKCkgeyB9XHJcbi8vIFdBUk5JTkc6IGludGVyZmFjZSBoYXMgYm90aCBhIHR5cGUgYW5kIGEgdmFsdWUsIHNraXBwaW5nIGVtaXRcclxuY29uc3QgybUwID0gLyoqXHJcbiAqIEBwYXJhbSB7Pz19IGRpclxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuKGRpciA9IHt9KSA9PiBkaXIsIMm1MSA9IC8qKlxyXG4gKiBAcGFyYW0gez99IHR5cGVcclxuICogQHBhcmFtIHs/fSBtZXRhXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG4odHlwZSwgbWV0YSkgPT4gU1dJVENIX0NPTVBJTEVfRElSRUNUSVZFKHR5cGUsIG1ldGEpO1xyXG4vKipcclxuICogVHlwZSBvZiB0aGUgRGlyZWN0aXZlIG1ldGFkYXRhLlxyXG4gKlxyXG4gKiBcXEBwdWJsaWNBcGlcclxuICogQHR5cGUgez99XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgRGlyZWN0aXZlID0gbWFrZURlY29yYXRvcignRGlyZWN0aXZlJywgKMm1MCksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCAoybUxKSk7XHJcbi8qKlxyXG4gKiBDb21wb25lbnQgZGVjb3JhdG9yIGludGVyZmFjZVxyXG4gKlxyXG4gKiBcXEBwdWJsaWNBcGlcclxuICogQHJlY29yZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIENvbXBvbmVudERlY29yYXRvcigpIHsgfVxyXG4vLyBXQVJOSU5HOiBpbnRlcmZhY2UgaGFzIGJvdGggYSB0eXBlIGFuZCBhIHZhbHVlLCBza2lwcGluZyBlbWl0XHJcbmNvbnN0IMm1MiA9IC8qKlxyXG4gKiBAcGFyYW0gez89fSBjXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG4oYyA9IHt9KSA9PiAoT2JqZWN0LmFzc2lnbih7IGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGVmYXVsdCB9LCBjKSksIMm1MyA9IC8qKlxyXG4gKiBAcGFyYW0gez99IHR5cGVcclxuICogQHBhcmFtIHs/fSBtZXRhXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG4odHlwZSwgbWV0YSkgPT4gU1dJVENIX0NPTVBJTEVfQ09NUE9ORU5UKHR5cGUsIG1ldGEpO1xyXG4vKipcclxuICogQ29tcG9uZW50IGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXHJcbiAqXHJcbiAqIFxcQEFubm90YXRpb25cclxuICogXFxAcHVibGljQXBpXHJcbiAqIEB0eXBlIHs/fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IENvbXBvbmVudCA9IG1ha2VEZWNvcmF0b3IoJ0NvbXBvbmVudCcsICjJtTIpLCBEaXJlY3RpdmUsIHVuZGVmaW5lZCwgKMm1MykpO1xyXG4vKipcclxuICogVHlwZSBvZiB0aGUgUGlwZSBkZWNvcmF0b3IgLyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cclxuICpcclxuICogXFxAcHVibGljQXBpXHJcbiAqIEByZWNvcmRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBQaXBlRGVjb3JhdG9yKCkgeyB9XHJcbi8vIFdBUk5JTkc6IGludGVyZmFjZSBoYXMgYm90aCBhIHR5cGUgYW5kIGEgdmFsdWUsIHNraXBwaW5nIGVtaXRcclxuY29uc3QgybU0ID0gLyoqXHJcbiAqIEBwYXJhbSB7P30gcFxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuKHApID0+IChPYmplY3QuYXNzaWduKHsgcHVyZTogdHJ1ZSB9LCBwKSksIMm1NSA9IC8qKlxyXG4gKiBAcGFyYW0gez99IHR5cGVcclxuICogQHBhcmFtIHs/fSBtZXRhXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG4odHlwZSwgbWV0YSkgPT4gU1dJVENIX0NPTVBJTEVfUElQRSh0eXBlLCBtZXRhKTtcclxuLyoqXHJcbiAqIFxcQEFubm90YXRpb25cclxuICogXFxAcHVibGljQXBpXHJcbiAqIEB0eXBlIHs/fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFBpcGUgPSBtYWtlRGVjb3JhdG9yKCdQaXBlJywgKMm1NCksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCAoybU1KSk7XHJcbi8qKlxyXG4gKiBcXEBwdWJsaWNBcGlcclxuICogQHJlY29yZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIElucHV0RGVjb3JhdG9yKCkgeyB9XHJcbi8vIFdBUk5JTkc6IGludGVyZmFjZSBoYXMgYm90aCBhIHR5cGUgYW5kIGEgdmFsdWUsIHNraXBwaW5nIGVtaXRcclxuY29uc3QgybU2ID0gLyoqXHJcbiAqIEBwYXJhbSB7Pz19IGJpbmRpbmdQcm9wZXJ0eU5hbWVcclxuICogQHJldHVybiB7P31cclxuICovXHJcbihiaW5kaW5nUHJvcGVydHlOYW1lKSA9PiAoeyBiaW5kaW5nUHJvcGVydHlOYW1lIH0pO1xyXG4vKipcclxuICogXFxAQW5ub3RhdGlvblxyXG4gKiBcXEBwdWJsaWNBcGlcclxuICogQHR5cGUgez99XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgSW5wdXQgPSBtYWtlUHJvcERlY29yYXRvcignSW5wdXQnLCAoybU2KSk7XHJcbi8qKlxyXG4gKiBUeXBlIG9mIHRoZSBPdXRwdXQgZGVjb3JhdG9yIC8gY29uc3RydWN0b3IgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIFxcQHB1YmxpY0FwaVxyXG4gKiBAcmVjb3JkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gT3V0cHV0RGVjb3JhdG9yKCkgeyB9XHJcbi8vIFdBUk5JTkc6IGludGVyZmFjZSBoYXMgYm90aCBhIHR5cGUgYW5kIGEgdmFsdWUsIHNraXBwaW5nIGVtaXRcclxuY29uc3QgybU3ID0gLyoqXHJcbiAqIEBwYXJhbSB7Pz19IGJpbmRpbmdQcm9wZXJ0eU5hbWVcclxuICogQHJldHVybiB7P31cclxuICovXHJcbihiaW5kaW5nUHJvcGVydHlOYW1lKSA9PiAoeyBiaW5kaW5nUHJvcGVydHlOYW1lIH0pO1xyXG4vKipcclxuICogXFxAQW5ub3RhdGlvblxyXG4gKiBcXEBwdWJsaWNBcGlcclxuICogQHR5cGUgez99XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgT3V0cHV0ID0gbWFrZVByb3BEZWNvcmF0b3IoJ091dHB1dCcsICjJtTcpKTtcclxuLyoqXHJcbiAqIFR5cGUgb2YgdGhlIEhvc3RCaW5kaW5nIGRlY29yYXRvciAvIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBcXEBwdWJsaWNBcGlcclxuICogQHJlY29yZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEhvc3RCaW5kaW5nRGVjb3JhdG9yKCkgeyB9XHJcbi8vIFdBUk5JTkc6IGludGVyZmFjZSBoYXMgYm90aCBhIHR5cGUgYW5kIGEgdmFsdWUsIHNraXBwaW5nIGVtaXRcclxuY29uc3QgybU4ID0gLyoqXHJcbiAqIEBwYXJhbSB7Pz19IGhvc3RQcm9wZXJ0eU5hbWVcclxuICogQHJldHVybiB7P31cclxuICovXHJcbihob3N0UHJvcGVydHlOYW1lKSA9PiAoeyBob3N0UHJvcGVydHlOYW1lIH0pO1xyXG4vKipcclxuICogXFxAQW5ub3RhdGlvblxyXG4gKiBcXEBwdWJsaWNBcGlcclxuICogQHR5cGUgez99XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgSG9zdEJpbmRpbmcgPSBtYWtlUHJvcERlY29yYXRvcignSG9zdEJpbmRpbmcnLCAoybU4KSk7XHJcbi8qKlxyXG4gKiBUeXBlIG9mIHRoZSBIb3N0TGlzdGVuZXIgZGVjb3JhdG9yIC8gY29uc3RydWN0b3IgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIFxcQHB1YmxpY0FwaVxyXG4gKiBAcmVjb3JkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gSG9zdExpc3RlbmVyRGVjb3JhdG9yKCkgeyB9XHJcbi8vIFdBUk5JTkc6IGludGVyZmFjZSBoYXMgYm90aCBhIHR5cGUgYW5kIGEgdmFsdWUsIHNraXBwaW5nIGVtaXRcclxuY29uc3QgybU5ID0gLyoqXHJcbiAqIEBwYXJhbSB7Pz19IGV2ZW50TmFtZVxyXG4gKiBAcGFyYW0gez89fSBhcmdzXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG4oZXZlbnROYW1lLCBhcmdzKSA9PiAoeyBldmVudE5hbWUsIGFyZ3MgfSk7XHJcbi8qKlxyXG4gKiBEZWNvcmF0b3IgdGhhdCBiaW5kcyBhIERPTSBldmVudCB0byBhIGhvc3QgbGlzdGVuZXIgYW5kIHN1cHBsaWVzIGNvbmZpZ3VyYXRpb24gbWV0YWRhdGEuXHJcbiAqIEFuZ3VsYXIgaW52b2tlcyB0aGUgc3VwcGxpZWQgaGFuZGxlciBtZXRob2Qgd2hlbiB0aGUgaG9zdCBlbGVtZW50IGVtaXRzIHRoZSBzcGVjaWZpZWQgZXZlbnQsXHJcbiAqIGFuZCB1cGRhdGVzIHRoZSBib3VuZCBlbGVtZW50IHdpdGggdGhlIHJlc3VsdC5cclxuICpcclxuICogSWYgdGhlIGhhbmRsZXIgbWV0aG9kIHJldHVybnMgZmFsc2UsIGFwcGxpZXMgYHByZXZlbnREZWZhdWx0YCBvbiB0aGUgYm91bmQgZWxlbWVudC5cclxuICpcclxuICogXFxAdXNhZ2VOb3Rlc1xyXG4gKlxyXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgZGVjbGFyZXMgYSBkaXJlY3RpdmVcclxuICogdGhhdCBhdHRhY2hlcyBhIGNsaWNrIGxpc3RlbmVyIHRvIGEgYnV0dG9uIGFuZCBjb3VudHMgY2xpY2tzLlxyXG4gKlxyXG4gKiBgYGB0c1xyXG4gKiBcXEBEaXJlY3RpdmUoe3NlbGVjdG9yOiAnYnV0dG9uW2NvdW50aW5nXSd9KVxyXG4gKiBjbGFzcyBDb3VudENsaWNrcyB7XHJcbiAqICAgbnVtYmVyT2ZDbGlja3MgPSAwO1xyXG4gKlxyXG4gKiBcXEBIb3N0TGlzdGVuZXIoJ2NsaWNrJywgWyckZXZlbnQudGFyZ2V0J10pXHJcbiAqICAgb25DbGljayhidG4pIHtcclxuICogICAgIGNvbnNvbGUubG9nKCdidXR0b24nLCBidG4sICdudW1iZXIgb2YgY2xpY2tzOicsIHRoaXMubnVtYmVyT2ZDbGlja3MrKyk7XHJcbiAqICB9XHJcbiAqIH1cclxuICpcclxuICogXFxAQ29tcG9uZW50KHtcclxuICogICBzZWxlY3RvcjogJ2FwcCcsXHJcbiAqICAgdGVtcGxhdGU6ICc8YnV0dG9uIGNvdW50aW5nPkluY3JlbWVudDwvYnV0dG9uPicsXHJcbiAqIH0pXHJcbiAqIGNsYXNzIEFwcCB7fVxyXG4gKiBgYGBcclxuICpcclxuICogXFxAQW5ub3RhdGlvblxyXG4gKiBcXEBwdWJsaWNBcGlcclxuICogQHR5cGUgez99XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgSG9zdExpc3RlbmVyID0gbWFrZVByb3BEZWNvcmF0b3IoJ0hvc3RMaXN0ZW5lcicsICjJtTkpKTtcclxuLyoqIEB0eXBlIHs/fSAqL1xyXG5leHBvcnQgY29uc3QgU1dJVENIX0NPTVBJTEVfQ09NUE9ORU5UX19QT1NUX1IzX18gPSByZW5kZXIzQ29tcGlsZUNvbXBvbmVudDtcclxuLyoqIEB0eXBlIHs/fSAqL1xyXG5leHBvcnQgY29uc3QgU1dJVENIX0NPTVBJTEVfRElSRUNUSVZFX19QT1NUX1IzX18gPSByZW5kZXIzQ29tcGlsZURpcmVjdGl2ZTtcclxuLyoqIEB0eXBlIHs/fSAqL1xyXG5leHBvcnQgY29uc3QgU1dJVENIX0NPTVBJTEVfUElQRV9fUE9TVF9SM19fID0gcmVuZGVyM0NvbXBpbGVQaXBlO1xyXG4vKiogQHR5cGUgez99ICovXHJcbmNvbnN0IFNXSVRDSF9DT01QSUxFX0NPTVBPTkVOVF9fUFJFX1IzX18gPSBub29wO1xyXG4vKiogQHR5cGUgez99ICovXHJcbmNvbnN0IFNXSVRDSF9DT01QSUxFX0RJUkVDVElWRV9fUFJFX1IzX18gPSBub29wO1xyXG4vKiogQHR5cGUgez99ICovXHJcbmNvbnN0IFNXSVRDSF9DT01QSUxFX1BJUEVfX1BSRV9SM19fID0gbm9vcDtcclxuLyoqIEB0eXBlIHs/fSAqL1xyXG5jb25zdCBTV0lUQ0hfQ09NUElMRV9DT01QT05FTlQgPSBTV0lUQ0hfQ09NUElMRV9DT01QT05FTlRfX1BSRV9SM19fO1xyXG4vKiogQHR5cGUgez99ICovXHJcbmNvbnN0IFNXSVRDSF9DT01QSUxFX0RJUkVDVElWRSA9IFNXSVRDSF9DT01QSUxFX0RJUkVDVElWRV9fUFJFX1IzX187XHJcbi8qKiBAdHlwZSB7P30gKi9cclxuY29uc3QgU1dJVENIX0NPTVBJTEVfUElQRSA9IFNXSVRDSF9DT01QSUxFX1BJUEVfX1BSRV9SM19fO1xyXG5leHBvcnQgeyDJtTAsIMm1MSwgybUyLCDJtTMsIMm1NCwgybU1LCDJtTYsIMm1NywgybU4LCDJtTkgfTtcciJdfQ==