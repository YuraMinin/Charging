/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ɵɵdefineInjector } from '../di/interface/defs';
import { convertInjectableProviderToFactory } from '../di/util';
import { compileNgModule as render3CompileNgModule } from '../render3/jit/module';
import { makeDecorator } from '../util/decorators';
/**
 * Represents the expansion of an `NgModule` into its scopes.
 *
 * A scope is a set of directives and pipes that are visible in a particular context. Each
 * `NgModule` has two scopes. The `compilation` scope is the set of directives and pipes that will
 * be recognized in the templates of components declared by the module. The `exported` scope is the
 * set of directives and pipes exported by a module (that is, module B's exported scope gets added
 * to module A's compilation scope when module A imports B).
 * @record
 */
export function NgModuleTransitiveScopes() { }
if (false) {
    /** @type {?} */
    NgModuleTransitiveScopes.prototype.compilation;
    /** @type {?} */
    NgModuleTransitiveScopes.prototype.exported;
    /** @type {?} */
    NgModuleTransitiveScopes.prototype.schemas;
}
/**
 * Runtime link information for NgModules.
 *
 * This is the internal data structure used by the runtime to assemble components, directives,
 * pipes, and injectors.
 *
 * NOTE: Always use `ɵɵdefineNgModule` function to create this object,
 * never create the object directly since the shape of this object
 * can change between versions.
 * @record
 * @template T
 */
export function NgModuleDef() { }
if (false) {
    /**
     * Token representing the module. Used by DI.
     * @type {?}
     */
    NgModuleDef.prototype.type;
    /**
     * List of components to bootstrap.
     * @type {?}
     */
    NgModuleDef.prototype.bootstrap;
    /**
     * List of components, directives, and pipes declared by this module.
     * @type {?}
     */
    NgModuleDef.prototype.declarations;
    /**
     * List of modules or `ModuleWithProviders` imported by this module.
     * @type {?}
     */
    NgModuleDef.prototype.imports;
    /**
     * List of modules, `ModuleWithProviders`, components, directives, or pipes exported by this
     * module.
     * @type {?}
     */
    NgModuleDef.prototype.exports;
    /**
     * Cached value of computed `transitiveCompileScopes` for this module.
     *
     * This should never be read directly, but accessed via `transitiveScopesFor`.
     * @type {?}
     */
    NgModuleDef.prototype.transitiveCompileScopes;
    /**
     * The set of schemas that declare elements to be allowed in the NgModule.
     * @type {?}
     */
    NgModuleDef.prototype.schemas;
    /**
     * Unique ID for the module with which it should be registered.
     * @type {?}
     */
    NgModuleDef.prototype.id;
}
/**
 * A wrapper around an NgModule that associates it with the providers.
 *
 * @param T the module type. In Ivy applications, this must be explicitly
 * provided.
 *
 * \@publicApi
 * @record
 * @template T
 */
export function ModuleWithProviders() { }
if (false) {
    /** @type {?} */
    ModuleWithProviders.prototype.ngModule;
    /** @type {?|undefined} */
    ModuleWithProviders.prototype.providers;
}
/**
 * Type of the NgModule decorator / constructor function.
 *
 * \@publicApi
 * @record
 */
export function NgModuleDecorator() { }
// WARNING: interface has both a type and a value, skipping emit
const ɵ0 = /**
 * @param {?} ngModule
 * @return {?}
 */
(ngModule) => ngModule, ɵ1 = /**
 * Decorator that marks the following class as an NgModule, and supplies
 * configuration metadata for it.
 *
 * * The `declarations` and `entryComponents` options configure the compiler
 * with information about what belongs to the NgModule.
 * * The `providers` options configures the NgModule's injector to provide
 * dependencies the NgModule members.
 * * The `imports` and `exports` options bring in members from other modules, and make
 * this module's members available to others.
 * @param {?} type
 * @param {?} meta
 * @return {?}
 */
(type, meta) => SWITCH_COMPILE_NGMODULE(type, meta);
/**
 * \@Annotation
 * \@publicApi
 * @type {?}
 */
export const NgModule = makeDecorator('NgModule', (ɵ0), undefined, undefined, (ɵ1));
/**
 * \@description
 * Hook for manual bootstrapping of the application instead of using bootstrap array in \@NgModule
 * annotation.
 *
 * Reference to the current application is provided as a parameter.
 *
 * See ["Bootstrapping"](guide/bootstrapping) and ["Entry components"](guide/entry-components).
 *
 * \@usageNotes
 * ```typescript
 * class AppModule implements DoBootstrap {
 *   ngDoBootstrap(appRef: ApplicationRef) {
 *     appRef.bootstrap(AppComponent); // Or some other component
 *   }
 * }
 * ```
 *
 * \@publicApi
 * @record
 */
export function DoBootstrap() { }
if (false) {
    /**
     * @param {?} appRef
     * @return {?}
     */
    DoBootstrap.prototype.ngDoBootstrap = function (appRef) { };
}
/**
 * @param {?} moduleType
 * @param {?=} metadata
 * @return {?}
 */
function preR3NgModuleCompile(moduleType, metadata) {
    /** @type {?} */
    let imports = (metadata && metadata.imports) || [];
    if (metadata && metadata.exports) {
        imports = [...imports, metadata.exports];
    }
    ((/** @type {?} */ (moduleType))).ngInjectorDef = ɵɵdefineInjector({
        factory: convertInjectableProviderToFactory(moduleType, { useClass: moduleType }),
        providers: metadata && metadata.providers,
        imports: imports,
    });
}
/** @type {?} */
export const SWITCH_COMPILE_NGMODULE__POST_R3__ = render3CompileNgModule;
/** @type {?} */
const SWITCH_COMPILE_NGMODULE__PRE_R3__ = preR3NgModuleCompile;
/** @type {?} */
const SWITCH_COMPILE_NGMODULE = SWITCH_COMPILE_NGMODULE__POST_R3__;
export { ɵ0, ɵ1 };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L1Byb2plY3RzL1Rlc3RQcm9qZWN0L0NoYXJnaW5nL0NoYXJnaW5nL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL2VzbTIwMTUvc3JjL21ldGFkYXRhL25nX21vZHVsZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnQ0FpTWdDLGtDQUFpQyIsImZpbGUiOiJuZ19tb2R1bGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXHJcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxjb25zdGFudFByb3BlcnR5LGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcclxuICovXHJcbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHsgybXJtWRlZmluZUluamVjdG9yIH0gZnJvbSAnLi4vZGkvaW50ZXJmYWNlL2RlZnMnO1xyXG5pbXBvcnQgeyBjb252ZXJ0SW5qZWN0YWJsZVByb3ZpZGVyVG9GYWN0b3J5IH0gZnJvbSAnLi4vZGkvdXRpbCc7XHJcbmltcG9ydCB7IGNvbXBpbGVOZ01vZHVsZSBhcyByZW5kZXIzQ29tcGlsZU5nTW9kdWxlIH0gZnJvbSAnLi4vcmVuZGVyMy9qaXQvbW9kdWxlJztcclxuaW1wb3J0IHsgbWFrZURlY29yYXRvciB9IGZyb20gJy4uL3V0aWwvZGVjb3JhdG9ycyc7XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSBleHBhbnNpb24gb2YgYW4gYE5nTW9kdWxlYCBpbnRvIGl0cyBzY29wZXMuXHJcbiAqXHJcbiAqIEEgc2NvcGUgaXMgYSBzZXQgb2YgZGlyZWN0aXZlcyBhbmQgcGlwZXMgdGhhdCBhcmUgdmlzaWJsZSBpbiBhIHBhcnRpY3VsYXIgY29udGV4dC4gRWFjaFxyXG4gKiBgTmdNb2R1bGVgIGhhcyB0d28gc2NvcGVzLiBUaGUgYGNvbXBpbGF0aW9uYCBzY29wZSBpcyB0aGUgc2V0IG9mIGRpcmVjdGl2ZXMgYW5kIHBpcGVzIHRoYXQgd2lsbFxyXG4gKiBiZSByZWNvZ25pemVkIGluIHRoZSB0ZW1wbGF0ZXMgb2YgY29tcG9uZW50cyBkZWNsYXJlZCBieSB0aGUgbW9kdWxlLiBUaGUgYGV4cG9ydGVkYCBzY29wZSBpcyB0aGVcclxuICogc2V0IG9mIGRpcmVjdGl2ZXMgYW5kIHBpcGVzIGV4cG9ydGVkIGJ5IGEgbW9kdWxlICh0aGF0IGlzLCBtb2R1bGUgQidzIGV4cG9ydGVkIHNjb3BlIGdldHMgYWRkZWRcclxuICogdG8gbW9kdWxlIEEncyBjb21waWxhdGlvbiBzY29wZSB3aGVuIG1vZHVsZSBBIGltcG9ydHMgQikuXHJcbiAqIEByZWNvcmRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBOZ01vZHVsZVRyYW5zaXRpdmVTY29wZXMoKSB7IH1cclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBOZ01vZHVsZVRyYW5zaXRpdmVTY29wZXMucHJvdG90eXBlLmNvbXBpbGF0aW9uO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgTmdNb2R1bGVUcmFuc2l0aXZlU2NvcGVzLnByb3RvdHlwZS5leHBvcnRlZDtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIE5nTW9kdWxlVHJhbnNpdGl2ZVNjb3Blcy5wcm90b3R5cGUuc2NoZW1hcztcclxufVxyXG4vKipcclxuICogUnVudGltZSBsaW5rIGluZm9ybWF0aW9uIGZvciBOZ01vZHVsZXMuXHJcbiAqXHJcbiAqIFRoaXMgaXMgdGhlIGludGVybmFsIGRhdGEgc3RydWN0dXJlIHVzZWQgYnkgdGhlIHJ1bnRpbWUgdG8gYXNzZW1ibGUgY29tcG9uZW50cywgZGlyZWN0aXZlcyxcclxuICogcGlwZXMsIGFuZCBpbmplY3RvcnMuXHJcbiAqXHJcbiAqIE5PVEU6IEFsd2F5cyB1c2UgYMm1ybVkZWZpbmVOZ01vZHVsZWAgZnVuY3Rpb24gdG8gY3JlYXRlIHRoaXMgb2JqZWN0LFxyXG4gKiBuZXZlciBjcmVhdGUgdGhlIG9iamVjdCBkaXJlY3RseSBzaW5jZSB0aGUgc2hhcGUgb2YgdGhpcyBvYmplY3RcclxuICogY2FuIGNoYW5nZSBiZXR3ZWVuIHZlcnNpb25zLlxyXG4gKiBAcmVjb3JkXHJcbiAqIEB0ZW1wbGF0ZSBUXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gTmdNb2R1bGVEZWYoKSB7IH1cclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKipcclxuICAgICAqIFRva2VuIHJlcHJlc2VudGluZyB0aGUgbW9kdWxlLiBVc2VkIGJ5IERJLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nTW9kdWxlRGVmLnByb3RvdHlwZS50eXBlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMaXN0IG9mIGNvbXBvbmVudHMgdG8gYm9vdHN0cmFwLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nTW9kdWxlRGVmLnByb3RvdHlwZS5ib290c3RyYXA7XHJcbiAgICAvKipcclxuICAgICAqIExpc3Qgb2YgY29tcG9uZW50cywgZGlyZWN0aXZlcywgYW5kIHBpcGVzIGRlY2xhcmVkIGJ5IHRoaXMgbW9kdWxlLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nTW9kdWxlRGVmLnByb3RvdHlwZS5kZWNsYXJhdGlvbnM7XHJcbiAgICAvKipcclxuICAgICAqIExpc3Qgb2YgbW9kdWxlcyBvciBgTW9kdWxlV2l0aFByb3ZpZGVyc2AgaW1wb3J0ZWQgYnkgdGhpcyBtb2R1bGUuXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdNb2R1bGVEZWYucHJvdG90eXBlLmltcG9ydHM7XHJcbiAgICAvKipcclxuICAgICAqIExpc3Qgb2YgbW9kdWxlcywgYE1vZHVsZVdpdGhQcm92aWRlcnNgLCBjb21wb25lbnRzLCBkaXJlY3RpdmVzLCBvciBwaXBlcyBleHBvcnRlZCBieSB0aGlzXHJcbiAgICAgKiBtb2R1bGUuXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdNb2R1bGVEZWYucHJvdG90eXBlLmV4cG9ydHM7XHJcbiAgICAvKipcclxuICAgICAqIENhY2hlZCB2YWx1ZSBvZiBjb21wdXRlZCBgdHJhbnNpdGl2ZUNvbXBpbGVTY29wZXNgIGZvciB0aGlzIG1vZHVsZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNob3VsZCBuZXZlciBiZSByZWFkIGRpcmVjdGx5LCBidXQgYWNjZXNzZWQgdmlhIGB0cmFuc2l0aXZlU2NvcGVzRm9yYC5cclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBOZ01vZHVsZURlZi5wcm90b3R5cGUudHJhbnNpdGl2ZUNvbXBpbGVTY29wZXM7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzZXQgb2Ygc2NoZW1hcyB0aGF0IGRlY2xhcmUgZWxlbWVudHMgdG8gYmUgYWxsb3dlZCBpbiB0aGUgTmdNb2R1bGUuXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgTmdNb2R1bGVEZWYucHJvdG90eXBlLnNjaGVtYXM7XHJcbiAgICAvKipcclxuICAgICAqIFVuaXF1ZSBJRCBmb3IgdGhlIG1vZHVsZSB3aXRoIHdoaWNoIGl0IHNob3VsZCBiZSByZWdpc3RlcmVkLlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKi9cclxuICAgIE5nTW9kdWxlRGVmLnByb3RvdHlwZS5pZDtcclxufVxyXG4vKipcclxuICogQSB3cmFwcGVyIGFyb3VuZCBhbiBOZ01vZHVsZSB0aGF0IGFzc29jaWF0ZXMgaXQgd2l0aCB0aGUgcHJvdmlkZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0gVCB0aGUgbW9kdWxlIHR5cGUuIEluIEl2eSBhcHBsaWNhdGlvbnMsIHRoaXMgbXVzdCBiZSBleHBsaWNpdGx5XHJcbiAqIHByb3ZpZGVkLlxyXG4gKlxyXG4gKiBcXEBwdWJsaWNBcGlcclxuICogQHJlY29yZFxyXG4gKiBAdGVtcGxhdGUgVFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIE1vZHVsZVdpdGhQcm92aWRlcnMoKSB7IH1cclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBNb2R1bGVXaXRoUHJvdmlkZXJzLnByb3RvdHlwZS5uZ01vZHVsZTtcclxuICAgIC8qKiBAdHlwZSB7P3x1bmRlZmluZWR9ICovXHJcbiAgICBNb2R1bGVXaXRoUHJvdmlkZXJzLnByb3RvdHlwZS5wcm92aWRlcnM7XHJcbn1cclxuLyoqXHJcbiAqIFR5cGUgb2YgdGhlIE5nTW9kdWxlIGRlY29yYXRvciAvIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBcXEBwdWJsaWNBcGlcclxuICogQHJlY29yZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIE5nTW9kdWxlRGVjb3JhdG9yKCkgeyB9XHJcbi8vIFdBUk5JTkc6IGludGVyZmFjZSBoYXMgYm90aCBhIHR5cGUgYW5kIGEgdmFsdWUsIHNraXBwaW5nIGVtaXRcclxuY29uc3QgybUwID0gLyoqXHJcbiAqIEBwYXJhbSB7P30gbmdNb2R1bGVcclxuICogQHJldHVybiB7P31cclxuICovXHJcbihuZ01vZHVsZSkgPT4gbmdNb2R1bGUsIMm1MSA9IC8qKlxyXG4gKiBEZWNvcmF0b3IgdGhhdCBtYXJrcyB0aGUgZm9sbG93aW5nIGNsYXNzIGFzIGFuIE5nTW9kdWxlLCBhbmQgc3VwcGxpZXNcclxuICogY29uZmlndXJhdGlvbiBtZXRhZGF0YSBmb3IgaXQuXHJcbiAqXHJcbiAqICogVGhlIGBkZWNsYXJhdGlvbnNgIGFuZCBgZW50cnlDb21wb25lbnRzYCBvcHRpb25zIGNvbmZpZ3VyZSB0aGUgY29tcGlsZXJcclxuICogd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJlbG9uZ3MgdG8gdGhlIE5nTW9kdWxlLlxyXG4gKiAqIFRoZSBgcHJvdmlkZXJzYCBvcHRpb25zIGNvbmZpZ3VyZXMgdGhlIE5nTW9kdWxlJ3MgaW5qZWN0b3IgdG8gcHJvdmlkZVxyXG4gKiBkZXBlbmRlbmNpZXMgdGhlIE5nTW9kdWxlIG1lbWJlcnMuXHJcbiAqICogVGhlIGBpbXBvcnRzYCBhbmQgYGV4cG9ydHNgIG9wdGlvbnMgYnJpbmcgaW4gbWVtYmVycyBmcm9tIG90aGVyIG1vZHVsZXMsIGFuZCBtYWtlXHJcbiAqIHRoaXMgbW9kdWxlJ3MgbWVtYmVycyBhdmFpbGFibGUgdG8gb3RoZXJzLlxyXG4gKiBAcGFyYW0gez99IHR5cGVcclxuICogQHBhcmFtIHs/fSBtZXRhXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG4odHlwZSwgbWV0YSkgPT4gU1dJVENIX0NPTVBJTEVfTkdNT0RVTEUodHlwZSwgbWV0YSk7XHJcbi8qKlxyXG4gKiBcXEBBbm5vdGF0aW9uXHJcbiAqIFxcQHB1YmxpY0FwaVxyXG4gKiBAdHlwZSB7P31cclxuICovXHJcbmV4cG9ydCBjb25zdCBOZ01vZHVsZSA9IG1ha2VEZWNvcmF0b3IoJ05nTW9kdWxlJywgKMm1MCksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCAoybUxKSk7XHJcbi8qKlxyXG4gKiBcXEBkZXNjcmlwdGlvblxyXG4gKiBIb29rIGZvciBtYW51YWwgYm9vdHN0cmFwcGluZyBvZiB0aGUgYXBwbGljYXRpb24gaW5zdGVhZCBvZiB1c2luZyBib290c3RyYXAgYXJyYXkgaW4gXFxATmdNb2R1bGVcclxuICogYW5ub3RhdGlvbi5cclxuICpcclxuICogUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGFwcGxpY2F0aW9uIGlzIHByb3ZpZGVkIGFzIGEgcGFyYW1ldGVyLlxyXG4gKlxyXG4gKiBTZWUgW1wiQm9vdHN0cmFwcGluZ1wiXShndWlkZS9ib290c3RyYXBwaW5nKSBhbmQgW1wiRW50cnkgY29tcG9uZW50c1wiXShndWlkZS9lbnRyeS1jb21wb25lbnRzKS5cclxuICpcclxuICogXFxAdXNhZ2VOb3Rlc1xyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIEFwcE1vZHVsZSBpbXBsZW1lbnRzIERvQm9vdHN0cmFwIHtcclxuICogICBuZ0RvQm9vdHN0cmFwKGFwcFJlZjogQXBwbGljYXRpb25SZWYpIHtcclxuICogICAgIGFwcFJlZi5ib290c3RyYXAoQXBwQ29tcG9uZW50KTsgLy8gT3Igc29tZSBvdGhlciBjb21wb25lbnRcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIFxcQHB1YmxpY0FwaVxyXG4gKiBAcmVjb3JkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gRG9Cb290c3RyYXAoKSB7IH1cclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gYXBwUmVmXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBEb0Jvb3RzdHJhcC5wcm90b3R5cGUubmdEb0Jvb3RzdHJhcCA9IGZ1bmN0aW9uIChhcHBSZWYpIHsgfTtcclxufVxyXG4vKipcclxuICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXHJcbiAqIEBwYXJhbSB7Pz19IG1ldGFkYXRhXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBwcmVSM05nTW9kdWxlQ29tcGlsZShtb2R1bGVUeXBlLCBtZXRhZGF0YSkge1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgbGV0IGltcG9ydHMgPSAobWV0YWRhdGEgJiYgbWV0YWRhdGEuaW1wb3J0cykgfHwgW107XHJcbiAgICBpZiAobWV0YWRhdGEgJiYgbWV0YWRhdGEuZXhwb3J0cykge1xyXG4gICAgICAgIGltcG9ydHMgPSBbLi4uaW1wb3J0cywgbWV0YWRhdGEuZXhwb3J0c107XHJcbiAgICB9XHJcbiAgICAoKC8qKiBAdHlwZSB7P30gKi8gKG1vZHVsZVR5cGUpKSkubmdJbmplY3RvckRlZiA9IMm1ybVkZWZpbmVJbmplY3Rvcih7XHJcbiAgICAgICAgZmFjdG9yeTogY29udmVydEluamVjdGFibGVQcm92aWRlclRvRmFjdG9yeShtb2R1bGVUeXBlLCB7IHVzZUNsYXNzOiBtb2R1bGVUeXBlIH0pLFxyXG4gICAgICAgIHByb3ZpZGVyczogbWV0YWRhdGEgJiYgbWV0YWRhdGEucHJvdmlkZXJzLFxyXG4gICAgICAgIGltcG9ydHM6IGltcG9ydHMsXHJcbiAgICB9KTtcclxufVxyXG4vKiogQHR5cGUgez99ICovXHJcbmV4cG9ydCBjb25zdCBTV0lUQ0hfQ09NUElMRV9OR01PRFVMRV9fUE9TVF9SM19fID0gcmVuZGVyM0NvbXBpbGVOZ01vZHVsZTtcclxuLyoqIEB0eXBlIHs/fSAqL1xyXG5jb25zdCBTV0lUQ0hfQ09NUElMRV9OR01PRFVMRV9fUFJFX1IzX18gPSBwcmVSM05nTW9kdWxlQ29tcGlsZTtcclxuLyoqIEB0eXBlIHs/fSAqL1xyXG5jb25zdCBTV0lUQ0hfQ09NUElMRV9OR01PRFVMRSA9IFNXSVRDSF9DT01QSUxFX05HTU9EVUxFX19QUkVfUjNfXztcclxuZXhwb3J0IHsgybUwLCDJtTEgfTtcciJdfQ==