/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ChangeDetectorRef, Injectable, Pipe, WrappedValue, ɵisObservable, ɵisPromise, ɵlooseIdentical } from '@angular/core';
import { invalidPipeArgumentError } from './invalid_pipe_argument_error';
/**
 * @record
 */
import * as ɵngcc0 from '@angular/core';
function SubscriptionStrategy() { }
if (false) {
    /**
     * @param {?} async
     * @param {?} updateLatestValue
     * @return {?}
     */
    SubscriptionStrategy.prototype.createSubscription = function (async, updateLatestValue) { };
    /**
     * @param {?} subscription
     * @return {?}
     */
    SubscriptionStrategy.prototype.dispose = function (subscription) { };
    /**
     * @param {?} subscription
     * @return {?}
     */
    SubscriptionStrategy.prototype.onDestroy = function (subscription) { };
}
class ObservableStrategy {
    /**
     * @param {?} async
     * @param {?} updateLatestValue
     * @return {?}
     */
    createSubscription(async, updateLatestValue) {
        return async.subscribe({ next: updateLatestValue, error: (/**
             * @param {?} e
             * @return {?}
             */
            (e) => { throw e; }) });
    }
    /**
     * @param {?} subscription
     * @return {?}
     */
    dispose(subscription) { subscription.unsubscribe(); }
    /**
     * @param {?} subscription
     * @return {?}
     */
    onDestroy(subscription) { subscription.unsubscribe(); }
}
class PromiseStrategy {
    /**
     * @param {?} async
     * @param {?} updateLatestValue
     * @return {?}
     */
    createSubscription(async, updateLatestValue) {
        return async.then(updateLatestValue, (/**
         * @param {?} e
         * @return {?}
         */
        e => { throw e; }));
    }
    /**
     * @param {?} subscription
     * @return {?}
     */
    dispose(subscription) { }
    /**
     * @param {?} subscription
     * @return {?}
     */
    onDestroy(subscription) { }
}
/** @type {?} */
const _promiseStrategy = new PromiseStrategy();
/** @type {?} */
const _observableStrategy = new ObservableStrategy();
/**
 * \@ngModule CommonModule
 * \@description
 *
 * Unwraps a value from an asynchronous primitive.
 *
 * The `async` pipe subscribes to an `Observable` or `Promise` and returns the latest value it has
 * emitted. When a new value is emitted, the `async` pipe marks the component to be checked for
 * changes. When the component gets destroyed, the `async` pipe unsubscribes automatically to avoid
 * potential memory leaks.
 *
 * \@usageNotes
 *
 * ### Examples
 *
 * This example binds a `Promise` to the view. Clicking the `Resolve` button resolves the
 * promise.
 *
 * {\@example common/pipes/ts/async_pipe.ts region='AsyncPipePromise'}
 *
 * It's also possible to use `async` with Observables. The example below binds the `time` Observable
 * to the view. The Observable continuously updates the view with the current time.
 *
 * {\@example common/pipes/ts/async_pipe.ts region='AsyncPipeObservable'}
 *
 * \@publicApi
 */
export class AsyncPipe {
    /**
     * @param {?} _ref
     */
    constructor(_ref) {
        this._ref = _ref;
        this._latestValue = null;
        this._latestReturnedValue = null;
        this._subscription = null;
        this._obj = null;
        this._strategy = (/** @type {?} */ (null));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._subscription) {
            this._dispose();
        }
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    transform(obj) {
        if (!this._obj) {
            if (obj) {
                this._subscribe(obj);
            }
            this._latestReturnedValue = this._latestValue;
            return this._latestValue;
        }
        if (obj !== this._obj) {
            this._dispose();
            return this.transform((/** @type {?} */ (obj)));
        }
        if (ɵlooseIdentical(this._latestValue, this._latestReturnedValue)) {
            return this._latestReturnedValue;
        }
        this._latestReturnedValue = this._latestValue;
        return WrappedValue.wrap(this._latestValue);
    }
    /**
     * @private
     * @param {?} obj
     * @return {?}
     */
    _subscribe(obj) {
        this._obj = obj;
        this._strategy = this._selectStrategy(obj);
        this._subscription = this._strategy.createSubscription(obj, (/**
         * @param {?} value
         * @return {?}
         */
        (value) => this._updateLatestValue(obj, value)));
    }
    /**
     * @private
     * @param {?} obj
     * @return {?}
     */
    _selectStrategy(obj) {
        if (ɵisPromise(obj)) {
            return _promiseStrategy;
        }
        if (ɵisObservable(obj)) {
            return _observableStrategy;
        }
        throw invalidPipeArgumentError(AsyncPipe, obj);
    }
    /**
     * @private
     * @return {?}
     */
    _dispose() {
        this._strategy.dispose((/** @type {?} */ (this._subscription)));
        this._latestValue = null;
        this._latestReturnedValue = null;
        this._subscription = null;
        this._obj = null;
    }
    /**
     * @private
     * @param {?} async
     * @param {?} value
     * @return {?}
     */
    _updateLatestValue(async, value) {
        if (async === this._obj) {
            this._latestValue = value;
            this._ref.markForCheck();
        }
    }
}
AsyncPipe.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: AsyncPipe, factory: function AsyncPipe_Factory(t) { return new (t || AsyncPipe)(ɵngcc0.ɵɵinject(ChangeDetectorRef)); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(AsyncPipe, [{
        type: Injectable
    }, {
        type: Pipe,
        args: [{ name: 'async', pure: false }]
    }], function () { return [{ type: ChangeDetectorRef }]; }, { constructor: [], _ref: [], _latestValue: [], _latestReturnedValue: [], _subscription: [], _obj: [], _strategy: [], ngOnDestroy: [], transform: [], _subscribe: [], _selectStrategy: [], _dispose: [], _updateLatestValue: [] });
AsyncPipe.ngPipeDef = ɵngcc0.ɵɵdefinePipe({ name: "async", type: AsyncPipe, factory: function AsyncPipe_Factory(t) { return new (t || AsyncPipe)(ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef)); }, pure: false });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(AsyncPipe, [{
        type: Injectable
    }, {
        type: Pipe,
        args: [{ name: 'async', pure: false }]
    }], function () { return [{ type: ChangeDetectorRef }]; }, { constructor: [], _ref: [], _latestValue: [], _latestReturnedValue: [], _subscription: [], _obj: [], _strategy: [], ngOnDestroy: [], transform: [], _subscribe: [], _selectStrategy: [], _dispose: [], _updateLatestValue: [] });
/** @nocollapse */
AsyncPipe.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    AsyncPipe.prototype._latestValue;
    /**
     * @type {?}
     * @private
     */
    AsyncPipe.prototype._latestReturnedValue;
    /**
     * @type {?}
     * @private
     */
    AsyncPipe.prototype._subscription;
    /**
     * @type {?}
     * @private
     */
    AsyncPipe.prototype._obj;
    /**
     * @type {?}
     * @private
     */
    AsyncPipe.prototype._strategy;
    /**
     * @type {?}
     * @private
     */
    AsyncPipe.prototype._ref;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L1Byb2plY3RzL1Rlc3RQcm9qZWN0L0NoYXJnaW5nL0NoYXJnaW5nL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vZXNtMjAxNS9zcmMvcGlwZXMvYXN5bmNfcGlwZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0ErTEMsZ1NBSUMiLCJmaWxlIjoiYXN5bmNfcGlwZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcclxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGNvbnN0YW50UHJvcGVydHksZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xyXG4gKi9cclxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgSW5qZWN0YWJsZSwgUGlwZSwgV3JhcHBlZFZhbHVlLCDJtWlzT2JzZXJ2YWJsZSwgybVpc1Byb21pc2UsIMm1bG9vc2VJZGVudGljYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgaW52YWxpZFBpcGVBcmd1bWVudEVycm9yIH0gZnJvbSAnLi9pbnZhbGlkX3BpcGVfYXJndW1lbnRfZXJyb3InO1xyXG4vKipcclxuICogQHJlY29yZFxyXG4gKi9cclxuZnVuY3Rpb24gU3Vic2NyaXB0aW9uU3RyYXRlZ3koKSB7IH1cclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gYXN5bmNcclxuICAgICAqIEBwYXJhbSB7P30gdXBkYXRlTGF0ZXN0VmFsdWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFN1YnNjcmlwdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5jcmVhdGVTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoYXN5bmMsIHVwZGF0ZUxhdGVzdFZhbHVlKSB7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gc3Vic2NyaXB0aW9uXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBTdWJzY3JpcHRpb25TdHJhdGVneS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBzdWJzY3JpcHRpb25cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIFN1YnNjcmlwdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7IH07XHJcbn1cclxuY2xhc3MgT2JzZXJ2YWJsZVN0cmF0ZWd5IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBhc3luY1xyXG4gICAgICogQHBhcmFtIHs/fSB1cGRhdGVMYXRlc3RWYWx1ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgY3JlYXRlU3Vic2NyaXB0aW9uKGFzeW5jLCB1cGRhdGVMYXRlc3RWYWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBhc3luYy5zdWJzY3JpYmUoeyBuZXh0OiB1cGRhdGVMYXRlc3RWYWx1ZSwgZXJyb3I6ICgvKipcclxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBlXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAoZSkgPT4geyB0aHJvdyBlOyB9KSB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBzdWJzY3JpcHRpb25cclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIGRpc3Bvc2Uoc3Vic2NyaXB0aW9uKSB7IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpOyB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gc3Vic2NyaXB0aW9uXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBvbkRlc3Ryb3koc3Vic2NyaXB0aW9uKSB7IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpOyB9XHJcbn1cclxuY2xhc3MgUHJvbWlzZVN0cmF0ZWd5IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBhc3luY1xyXG4gICAgICogQHBhcmFtIHs/fSB1cGRhdGVMYXRlc3RWYWx1ZVxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgY3JlYXRlU3Vic2NyaXB0aW9uKGFzeW5jLCB1cGRhdGVMYXRlc3RWYWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBhc3luYy50aGVuKHVwZGF0ZUxhdGVzdFZhbHVlLCAoLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSBlXHJcbiAgICAgICAgICogQHJldHVybiB7P31cclxuICAgICAgICAgKi9cclxuICAgICAgICBlID0+IHsgdGhyb3cgZTsgfSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHN1YnNjcmlwdGlvblxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZGlzcG9zZShzdWJzY3JpcHRpb24pIHsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHN1YnNjcmlwdGlvblxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgb25EZXN0cm95KHN1YnNjcmlwdGlvbikgeyB9XHJcbn1cclxuLyoqIEB0eXBlIHs/fSAqL1xyXG5jb25zdCBfcHJvbWlzZVN0cmF0ZWd5ID0gbmV3IFByb21pc2VTdHJhdGVneSgpO1xyXG4vKiogQHR5cGUgez99ICovXHJcbmNvbnN0IF9vYnNlcnZhYmxlU3RyYXRlZ3kgPSBuZXcgT2JzZXJ2YWJsZVN0cmF0ZWd5KCk7XHJcbi8qKlxyXG4gKiBcXEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcclxuICogXFxAZGVzY3JpcHRpb25cclxuICpcclxuICogVW53cmFwcyBhIHZhbHVlIGZyb20gYW4gYXN5bmNocm9ub3VzIHByaW1pdGl2ZS5cclxuICpcclxuICogVGhlIGBhc3luY2AgcGlwZSBzdWJzY3JpYmVzIHRvIGFuIGBPYnNlcnZhYmxlYCBvciBgUHJvbWlzZWAgYW5kIHJldHVybnMgdGhlIGxhdGVzdCB2YWx1ZSBpdCBoYXNcclxuICogZW1pdHRlZC4gV2hlbiBhIG5ldyB2YWx1ZSBpcyBlbWl0dGVkLCB0aGUgYGFzeW5jYCBwaXBlIG1hcmtzIHRoZSBjb21wb25lbnQgdG8gYmUgY2hlY2tlZCBmb3JcclxuICogY2hhbmdlcy4gV2hlbiB0aGUgY29tcG9uZW50IGdldHMgZGVzdHJveWVkLCB0aGUgYGFzeW5jYCBwaXBlIHVuc3Vic2NyaWJlcyBhdXRvbWF0aWNhbGx5IHRvIGF2b2lkXHJcbiAqIHBvdGVudGlhbCBtZW1vcnkgbGVha3MuXHJcbiAqXHJcbiAqIFxcQHVzYWdlTm90ZXNcclxuICpcclxuICogIyMjIEV4YW1wbGVzXHJcbiAqXHJcbiAqIFRoaXMgZXhhbXBsZSBiaW5kcyBhIGBQcm9taXNlYCB0byB0aGUgdmlldy4gQ2xpY2tpbmcgdGhlIGBSZXNvbHZlYCBidXR0b24gcmVzb2x2ZXMgdGhlXHJcbiAqIHByb21pc2UuXHJcbiAqXHJcbiAqIHtcXEBleGFtcGxlIGNvbW1vbi9waXBlcy90cy9hc3luY19waXBlLnRzIHJlZ2lvbj0nQXN5bmNQaXBlUHJvbWlzZSd9XHJcbiAqXHJcbiAqIEl0J3MgYWxzbyBwb3NzaWJsZSB0byB1c2UgYGFzeW5jYCB3aXRoIE9ic2VydmFibGVzLiBUaGUgZXhhbXBsZSBiZWxvdyBiaW5kcyB0aGUgYHRpbWVgIE9ic2VydmFibGVcclxuICogdG8gdGhlIHZpZXcuIFRoZSBPYnNlcnZhYmxlIGNvbnRpbnVvdXNseSB1cGRhdGVzIHRoZSB2aWV3IHdpdGggdGhlIGN1cnJlbnQgdGltZS5cclxuICpcclxuICoge1xcQGV4YW1wbGUgY29tbW9uL3BpcGVzL3RzL2FzeW5jX3BpcGUudHMgcmVnaW9uPSdBc3luY1BpcGVPYnNlcnZhYmxlJ31cclxuICpcclxuICogXFxAcHVibGljQXBpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQXN5bmNQaXBlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHs/fSBfcmVmXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9yZWYpIHtcclxuICAgICAgICB0aGlzLl9yZWYgPSBfcmVmO1xyXG4gICAgICAgIHRoaXMuX2xhdGVzdFZhbHVlID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX29iaiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fc3RyYXRlZ3kgPSAoLyoqIEB0eXBlIHs/fSAqLyAobnVsbCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBuZ09uRGVzdHJveSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gb2JqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICB0cmFuc2Zvcm0ob2JqKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9vYmopIHtcclxuICAgICAgICAgICAgaWYgKG9iaikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKG9iaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZSA9IHRoaXMuX2xhdGVzdFZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF0ZXN0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvYmogIT09IHRoaXMuX29iaikge1xyXG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSgoLyoqIEB0eXBlIHs/fSAqLyAob2JqKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoybVsb29zZUlkZW50aWNhbCh0aGlzLl9sYXRlc3RWYWx1ZSwgdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWUgPSB0aGlzLl9sYXRlc3RWYWx1ZTtcclxuICAgICAgICByZXR1cm4gV3JhcHBlZFZhbHVlLndyYXAodGhpcy5fbGF0ZXN0VmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHs/fSBvYmpcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIF9zdWJzY3JpYmUob2JqKSB7XHJcbiAgICAgICAgdGhpcy5fb2JqID0gb2JqO1xyXG4gICAgICAgIHRoaXMuX3N0cmF0ZWd5ID0gdGhpcy5fc2VsZWN0U3RyYXRlZ3kob2JqKTtcclxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSB0aGlzLl9zdHJhdGVneS5jcmVhdGVTdWJzY3JpcHRpb24ob2JqLCAoLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgKHZhbHVlKSA9PiB0aGlzLl91cGRhdGVMYXRlc3RWYWx1ZShvYmosIHZhbHVlKSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHs/fSBvYmpcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIF9zZWxlY3RTdHJhdGVneShvYmopIHtcclxuICAgICAgICBpZiAoybVpc1Byb21pc2Uob2JqKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3Byb21pc2VTdHJhdGVneTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKMm1aXNPYnNlcnZhYmxlKG9iaikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9vYnNlcnZhYmxlU3RyYXRlZ3k7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IGludmFsaWRQaXBlQXJndW1lbnRFcnJvcihBc3luY1BpcGUsIG9iaik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBfZGlzcG9zZSgpIHtcclxuICAgICAgICB0aGlzLl9zdHJhdGVneS5kaXNwb3NlKCgvKiogQHR5cGUgez99ICovICh0aGlzLl9zdWJzY3JpcHRpb24pKSk7XHJcbiAgICAgICAgdGhpcy5fbGF0ZXN0VmFsdWUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fb2JqID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7P30gYXN5bmNcclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcclxuICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgKi9cclxuICAgIF91cGRhdGVMYXRlc3RWYWx1ZShhc3luYywgdmFsdWUpIHtcclxuICAgICAgICBpZiAoYXN5bmMgPT09IHRoaXMuX29iaikge1xyXG4gICAgICAgICAgICB0aGlzLl9sYXRlc3RWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLl9yZWYubWFya0ZvckNoZWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbkFzeW5jUGlwZS5kZWNvcmF0b3JzID0gW1xyXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXHJcbiAgICB7IHR5cGU6IFBpcGUsIGFyZ3M6IFt7IG5hbWU6ICdhc3luYycsIHB1cmU6IGZhbHNlIH0sXSB9XHJcbl07XHJcbi8qKiBAbm9jb2xsYXBzZSAqL1xyXG5Bc3luY1BpcGUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXHJcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH1cclxuXTtcclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgQXN5bmNQaXBlLnByb3RvdHlwZS5fbGF0ZXN0VmFsdWU7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgQXN5bmNQaXBlLnByb3RvdHlwZS5fbGF0ZXN0UmV0dXJuZWRWYWx1ZTtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBBc3luY1BpcGUucHJvdG90eXBlLl9zdWJzY3JpcHRpb247XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgQXN5bmNQaXBlLnByb3RvdHlwZS5fb2JqO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIEFzeW5jUGlwZS5wcm90b3R5cGUuX3N0cmF0ZWd5O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIEFzeW5jUGlwZS5wcm90b3R5cGUuX3JlZjtcclxufVxyIl19