/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Injectable, KeyValueDiffers, Pipe } from '@angular/core';
/**
 * @template K, V
 * @param {?} key
 * @param {?} value
 * @return {?}
 */
import * as ɵngcc0 from '@angular/core';
function makeKeyValuePair(key, value) {
    return { key: key, value: value };
}
/**
 * A key value pair.
 * Usually used to represent the key value pairs from a Map or Object.
 *
 * \@publicApi
 * @record
 * @template K, V
 */
export function KeyValue() { }
if (false) {
    /** @type {?} */
    KeyValue.prototype.key;
    /** @type {?} */
    KeyValue.prototype.value;
}
/**
 * \@ngModule CommonModule
 * \@description
 *
 * Transforms Object or Map into an array of key value pairs.
 *
 * The output array will be ordered by keys.
 * By default the comparator will be by Unicode point value.
 * You can optionally pass a compareFn if your keys are complex types.
 *
 * \@usageNotes
 * ### Examples
 *
 * This examples show how an Object or a Map can be iterated by ngFor with the use of this keyvalue
 * pipe.
 *
 * {\@example common/pipes/ts/keyvalue_pipe.ts region='KeyValuePipe'}
 *
 * \@publicApi
 */
export class KeyValuePipe {
    /**
     * @param {?} differs
     */
    constructor(differs) {
        this.differs = differs;
        this.keyValues = [];
    }
    /**
     * @template K, V
     * @param {?} input
     * @param {?=} compareFn
     * @return {?}
     */
    transform(input, compareFn = defaultComparator) {
        if (!input || (!(input instanceof Map) && typeof input !== 'object')) {
            return null;
        }
        if (!this.differ) {
            // make a differ for whatever type we've been passed in
            this.differ = this.differs.find(input).create();
        }
        /** @type {?} */
        const differChanges = this.differ.diff((/** @type {?} */ (input)));
        if (differChanges) {
            this.keyValues = [];
            differChanges.forEachItem((/**
             * @param {?} r
             * @return {?}
             */
            (r) => {
                this.keyValues.push(makeKeyValuePair(r.key, (/** @type {?} */ (r.currentValue))));
            }));
            this.keyValues.sort(compareFn);
        }
        return this.keyValues;
    }
}
KeyValuePipe.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: KeyValuePipe, factory: function KeyValuePipe_Factory(t) { return new (t || KeyValuePipe)(ɵngcc0.ɵɵinject(KeyValueDiffers)); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(KeyValuePipe, [{
        type: Injectable
    }, {
        type: Pipe,
        args: [{ name: 'keyvalue', pure: false }]
    }], function () { return [{ type: KeyValueDiffers }]; }, { constructor: [], differs: [], keyValues: [], transform: [], differ: [] });
KeyValuePipe.ngPipeDef = ɵngcc0.ɵɵdefinePipe({ name: "keyvalue", type: KeyValuePipe, factory: function KeyValuePipe_Factory(t) { return new (t || KeyValuePipe)(ɵngcc0.ɵɵdirectiveInject(KeyValueDiffers)); }, pure: false });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(KeyValuePipe, [{
        type: Injectable
    }, {
        type: Pipe,
        args: [{ name: 'keyvalue', pure: false }]
    }], function () { return [{ type: KeyValueDiffers }]; }, { constructor: [], differs: [], keyValues: [], transform: [], differ: [] });
/** @nocollapse */
KeyValuePipe.ctorParameters = () => [
    { type: KeyValueDiffers }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    KeyValuePipe.prototype.differ;
    /**
     * @type {?}
     * @private
     */
    KeyValuePipe.prototype.keyValues;
    /**
     * @type {?}
     * @private
     */
    KeyValuePipe.prototype.differs;
}
/**
 * @template K, V
 * @param {?} keyValueA
 * @param {?} keyValueB
 * @return {?}
 */
export function defaultComparator(keyValueA, keyValueB) {
    /** @type {?} */
    const a = keyValueA.key;
    /** @type {?} */
    const b = keyValueB.key;
    // if same exit with 0;
    if (a === b)
        return 0;
    // make sure that undefined are at the end of the sort.
    if (a === undefined)
        return 1;
    if (b === undefined)
        return -1;
    // make sure that nulls are at the end of the sort.
    if (a === null)
        return 1;
    if (b === null)
        return -1;
    if (typeof a == 'string' && typeof b == 'string') {
        return a < b ? -1 : 1;
    }
    if (typeof a == 'number' && typeof b == 'number') {
        return a - b;
    }
    if (typeof a == 'boolean' && typeof b == 'boolean') {
        return a < b ? -1 : 1;
    }
    // `a` and `b` are of different types. Compare their string values.
    /** @type {?} */
    const aString = String(a);
    /** @type {?} */
    const bString = String(b);
    return aString == bString ? 0 : aString < bString ? -1 : 1;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L1Byb2plY3RzL1Rlc3RQcm9qZWN0L0NoYXJnaW5nL0NoYXJnaW5nL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vZXNtMjAxNS9zcmMvcGlwZXMva2V5dmFsdWVfcGlwZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EyRUMsd0lBSUMiLCJmaWxlIjoia2V5dmFsdWVfcGlwZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcclxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGNvbnN0YW50UHJvcGVydHksZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xyXG4gKi9cclxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBLZXlWYWx1ZURpZmZlcnMsIFBpcGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuLyoqXHJcbiAqIEB0ZW1wbGF0ZSBLLCBWXHJcbiAqIEBwYXJhbSB7P30ga2V5XHJcbiAqIEBwYXJhbSB7P30gdmFsdWVcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIG1ha2VLZXlWYWx1ZVBhaXIoa2V5LCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9O1xyXG59XHJcbi8qKlxyXG4gKiBBIGtleSB2YWx1ZSBwYWlyLlxyXG4gKiBVc3VhbGx5IHVzZWQgdG8gcmVwcmVzZW50IHRoZSBrZXkgdmFsdWUgcGFpcnMgZnJvbSBhIE1hcCBvciBPYmplY3QuXHJcbiAqXHJcbiAqIFxcQHB1YmxpY0FwaVxyXG4gKiBAcmVjb3JkXHJcbiAqIEB0ZW1wbGF0ZSBLLCBWXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gS2V5VmFsdWUoKSB7IH1cclxuaWYgKGZhbHNlKSB7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBLZXlWYWx1ZS5wcm90b3R5cGUua2V5O1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgS2V5VmFsdWUucHJvdG90eXBlLnZhbHVlO1xyXG59XHJcbi8qKlxyXG4gKiBcXEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcclxuICogXFxAZGVzY3JpcHRpb25cclxuICpcclxuICogVHJhbnNmb3JtcyBPYmplY3Qgb3IgTWFwIGludG8gYW4gYXJyYXkgb2Yga2V5IHZhbHVlIHBhaXJzLlxyXG4gKlxyXG4gKiBUaGUgb3V0cHV0IGFycmF5IHdpbGwgYmUgb3JkZXJlZCBieSBrZXlzLlxyXG4gKiBCeSBkZWZhdWx0IHRoZSBjb21wYXJhdG9yIHdpbGwgYmUgYnkgVW5pY29kZSBwb2ludCB2YWx1ZS5cclxuICogWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgYSBjb21wYXJlRm4gaWYgeW91ciBrZXlzIGFyZSBjb21wbGV4IHR5cGVzLlxyXG4gKlxyXG4gKiBcXEB1c2FnZU5vdGVzXHJcbiAqICMjIyBFeGFtcGxlc1xyXG4gKlxyXG4gKiBUaGlzIGV4YW1wbGVzIHNob3cgaG93IGFuIE9iamVjdCBvciBhIE1hcCBjYW4gYmUgaXRlcmF0ZWQgYnkgbmdGb3Igd2l0aCB0aGUgdXNlIG9mIHRoaXMga2V5dmFsdWVcclxuICogcGlwZS5cclxuICpcclxuICoge1xcQGV4YW1wbGUgY29tbW9uL3BpcGVzL3RzL2tleXZhbHVlX3BpcGUudHMgcmVnaW9uPSdLZXlWYWx1ZVBpcGUnfVxyXG4gKlxyXG4gKiBcXEBwdWJsaWNBcGlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBLZXlWYWx1ZVBpcGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IGRpZmZlcnNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZGlmZmVycykge1xyXG4gICAgICAgIHRoaXMuZGlmZmVycyA9IGRpZmZlcnM7XHJcbiAgICAgICAgdGhpcy5rZXlWYWx1ZXMgPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHRlbXBsYXRlIEssIFZcclxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbXBhcmVGblxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgdHJhbnNmb3JtKGlucHV0LCBjb21wYXJlRm4gPSBkZWZhdWx0Q29tcGFyYXRvcikge1xyXG4gICAgICAgIGlmICghaW5wdXQgfHwgKCEoaW5wdXQgaW5zdGFuY2VvZiBNYXApICYmIHR5cGVvZiBpbnB1dCAhPT0gJ29iamVjdCcpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuZGlmZmVyKSB7XHJcbiAgICAgICAgICAgIC8vIG1ha2UgYSBkaWZmZXIgZm9yIHdoYXRldmVyIHR5cGUgd2UndmUgYmVlbiBwYXNzZWQgaW5cclxuICAgICAgICAgICAgdGhpcy5kaWZmZXIgPSB0aGlzLmRpZmZlcnMuZmluZChpbnB1dCkuY3JlYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICBjb25zdCBkaWZmZXJDaGFuZ2VzID0gdGhpcy5kaWZmZXIuZGlmZigoLyoqIEB0eXBlIHs/fSAqLyAoaW5wdXQpKSk7XHJcbiAgICAgICAgaWYgKGRpZmZlckNoYW5nZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5rZXlWYWx1ZXMgPSBbXTtcclxuICAgICAgICAgICAgZGlmZmVyQ2hhbmdlcy5mb3JFYWNoSXRlbSgoLyoqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gclxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgKHIpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMua2V5VmFsdWVzLnB1c2gobWFrZUtleVZhbHVlUGFpcihyLmtleSwgKC8qKiBAdHlwZSB7P30gKi8gKHIuY3VycmVudFZhbHVlKSkpKTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB0aGlzLmtleVZhbHVlcy5zb3J0KGNvbXBhcmVGbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmtleVZhbHVlcztcclxuICAgIH1cclxufVxyXG5LZXlWYWx1ZVBpcGUuZGVjb3JhdG9ycyA9IFtcclxuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxyXG4gICAgeyB0eXBlOiBQaXBlLCBhcmdzOiBbeyBuYW1lOiAna2V5dmFsdWUnLCBwdXJlOiBmYWxzZSB9LF0gfVxyXG5dO1xyXG4vKiogQG5vY29sbGFwc2UgKi9cclxuS2V5VmFsdWVQaXBlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xyXG4gICAgeyB0eXBlOiBLZXlWYWx1ZURpZmZlcnMgfVxyXG5dO1xyXG5pZiAoZmFsc2UpIHtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBLZXlWYWx1ZVBpcGUucHJvdG90eXBlLmRpZmZlcjtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBLZXlWYWx1ZVBpcGUucHJvdG90eXBlLmtleVZhbHVlcztcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgez99XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBLZXlWYWx1ZVBpcGUucHJvdG90eXBlLmRpZmZlcnM7XHJcbn1cclxuLyoqXHJcbiAqIEB0ZW1wbGF0ZSBLLCBWXHJcbiAqIEBwYXJhbSB7P30ga2V5VmFsdWVBXHJcbiAqIEBwYXJhbSB7P30ga2V5VmFsdWVCXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdENvbXBhcmF0b3Ioa2V5VmFsdWVBLCBrZXlWYWx1ZUIpIHtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIGNvbnN0IGEgPSBrZXlWYWx1ZUEua2V5O1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgY29uc3QgYiA9IGtleVZhbHVlQi5rZXk7XHJcbiAgICAvLyBpZiBzYW1lIGV4aXQgd2l0aCAwO1xyXG4gICAgaWYgKGEgPT09IGIpXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAvLyBtYWtlIHN1cmUgdGhhdCB1bmRlZmluZWQgYXJlIGF0IHRoZSBlbmQgb2YgdGhlIHNvcnQuXHJcbiAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgaWYgKGIgPT09IHVuZGVmaW5lZClcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAvLyBtYWtlIHN1cmUgdGhhdCBudWxscyBhcmUgYXQgdGhlIGVuZCBvZiB0aGUgc29ydC5cclxuICAgIGlmIChhID09PSBudWxsKVxyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgaWYgKGIgPT09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgaWYgKHR5cGVvZiBhID09ICdzdHJpbmcnICYmIHR5cGVvZiBiID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiAxO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBhID09ICdudW1iZXInICYmIHR5cGVvZiBiID09ICdudW1iZXInKSB7XHJcbiAgICAgICAgcmV0dXJuIGEgLSBiO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBhID09ICdib29sZWFuJyAmJiB0eXBlb2YgYiA9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IDE7XHJcbiAgICB9XHJcbiAgICAvLyBgYWAgYW5kIGBiYCBhcmUgb2YgZGlmZmVyZW50IHR5cGVzLiBDb21wYXJlIHRoZWlyIHN0cmluZyB2YWx1ZXMuXHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBjb25zdCBhU3RyaW5nID0gU3RyaW5nKGEpO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgY29uc3QgYlN0cmluZyA9IFN0cmluZyhiKTtcclxuICAgIHJldHVybiBhU3RyaW5nID09IGJTdHJpbmcgPyAwIDogYVN0cmluZyA8IGJTdHJpbmcgPyAtMSA6IDE7XHJcbn1cciJdfQ==