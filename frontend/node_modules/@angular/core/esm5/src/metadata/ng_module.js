/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as tslib_1 from "tslib";
import { ɵɵdefineInjector } from '../di/interface/defs';
import { convertInjectableProviderToFactory } from '../di/util';
import { compileNgModule as render3CompileNgModule } from '../render3/jit/module';
import { makeDecorator } from '../util/decorators';
var ɵ0 = function (ngModule) { return ngModule; }, ɵ1 = 
/**
 * Decorator that marks the following class as an NgModule, and supplies
 * configuration metadata for it.
 *
 * * The `declarations` and `entryComponents` options configure the compiler
 * with information about what belongs to the NgModule.
 * * The `providers` options configures the NgModule's injector to provide
 * dependencies the NgModule members.
 * * The `imports` and `exports` options bring in members from other modules, and make
 * this module's members available to others.
 */
function (type, meta) { return SWITCH_COMPILE_NGMODULE(type, meta); };
/**
 * @Annotation
 * @publicApi
 */
export var NgModule = makeDecorator('NgModule', ɵ0, undefined, undefined, ɵ1);
function preR3NgModuleCompile(moduleType, metadata) {
    var imports = (metadata && metadata.imports) || [];
    if (metadata && metadata.exports) {
        imports = tslib_1.__spread(imports, [metadata.exports]);
    }
    moduleType.ngInjectorDef = ɵɵdefineInjector({
        factory: convertInjectableProviderToFactory(moduleType, { useClass: moduleType }),
        providers: metadata && metadata.providers,
        imports: imports,
    });
}
export var SWITCH_COMPILE_NGMODULE__POST_R3__ = render3CompileNgModule;
var SWITCH_COMPILE_NGMODULE__PRE_R3__ = preR3NgModuleCompile;
var SWITCH_COMPILE_NGMODULE = SWITCH_COMPILE_NGMODULE__POST_R3__;
export { ɵ0, ɵ1 };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L1Byb2plY3RzL1Rlc3RQcm9qZWN0L0NoYXJnaW5nL0NoYXJnaW5nL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL2VzbTUvc3JjL21ldGFkYXRhL25nX21vZHVsZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4QkEyQzhCLGtDQUFpQyIsImZpbGUiOiJuZ19tb2R1bGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXHJcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcclxuICovXHJcbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IMm1ybVkZWZpbmVJbmplY3RvciB9IGZyb20gJy4uL2RpL2ludGVyZmFjZS9kZWZzJztcclxuaW1wb3J0IHsgY29udmVydEluamVjdGFibGVQcm92aWRlclRvRmFjdG9yeSB9IGZyb20gJy4uL2RpL3V0aWwnO1xyXG5pbXBvcnQgeyBjb21waWxlTmdNb2R1bGUgYXMgcmVuZGVyM0NvbXBpbGVOZ01vZHVsZSB9IGZyb20gJy4uL3JlbmRlcjMvaml0L21vZHVsZSc7XHJcbmltcG9ydCB7IG1ha2VEZWNvcmF0b3IgfSBmcm9tICcuLi91dGlsL2RlY29yYXRvcnMnO1xyXG52YXIgybUwID0gZnVuY3Rpb24gKG5nTW9kdWxlKSB7IHJldHVybiBuZ01vZHVsZTsgfSwgybUxID0gXHJcbi8qKlxyXG4gKiBEZWNvcmF0b3IgdGhhdCBtYXJrcyB0aGUgZm9sbG93aW5nIGNsYXNzIGFzIGFuIE5nTW9kdWxlLCBhbmQgc3VwcGxpZXNcclxuICogY29uZmlndXJhdGlvbiBtZXRhZGF0YSBmb3IgaXQuXHJcbiAqXHJcbiAqICogVGhlIGBkZWNsYXJhdGlvbnNgIGFuZCBgZW50cnlDb21wb25lbnRzYCBvcHRpb25zIGNvbmZpZ3VyZSB0aGUgY29tcGlsZXJcclxuICogd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJlbG9uZ3MgdG8gdGhlIE5nTW9kdWxlLlxyXG4gKiAqIFRoZSBgcHJvdmlkZXJzYCBvcHRpb25zIGNvbmZpZ3VyZXMgdGhlIE5nTW9kdWxlJ3MgaW5qZWN0b3IgdG8gcHJvdmlkZVxyXG4gKiBkZXBlbmRlbmNpZXMgdGhlIE5nTW9kdWxlIG1lbWJlcnMuXHJcbiAqICogVGhlIGBpbXBvcnRzYCBhbmQgYGV4cG9ydHNgIG9wdGlvbnMgYnJpbmcgaW4gbWVtYmVycyBmcm9tIG90aGVyIG1vZHVsZXMsIGFuZCBtYWtlXHJcbiAqIHRoaXMgbW9kdWxlJ3MgbWVtYmVycyBhdmFpbGFibGUgdG8gb3RoZXJzLlxyXG4gKi9cclxuZnVuY3Rpb24gKHR5cGUsIG1ldGEpIHsgcmV0dXJuIFNXSVRDSF9DT01QSUxFX05HTU9EVUxFKHR5cGUsIG1ldGEpOyB9O1xyXG4vKipcclxuICogQEFubm90YXRpb25cclxuICogQHB1YmxpY0FwaVxyXG4gKi9cclxuZXhwb3J0IHZhciBOZ01vZHVsZSA9IG1ha2VEZWNvcmF0b3IoJ05nTW9kdWxlJywgybUwLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgybUxKTtcclxuZnVuY3Rpb24gcHJlUjNOZ01vZHVsZUNvbXBpbGUobW9kdWxlVHlwZSwgbWV0YWRhdGEpIHtcclxuICAgIHZhciBpbXBvcnRzID0gKG1ldGFkYXRhICYmIG1ldGFkYXRhLmltcG9ydHMpIHx8IFtdO1xyXG4gICAgaWYgKG1ldGFkYXRhICYmIG1ldGFkYXRhLmV4cG9ydHMpIHtcclxuICAgICAgICBpbXBvcnRzID0gdHNsaWJfMS5fX3NwcmVhZChpbXBvcnRzLCBbbWV0YWRhdGEuZXhwb3J0c10pO1xyXG4gICAgfVxyXG4gICAgbW9kdWxlVHlwZS5uZ0luamVjdG9yRGVmID0gybXJtWRlZmluZUluamVjdG9yKHtcclxuICAgICAgICBmYWN0b3J5OiBjb252ZXJ0SW5qZWN0YWJsZVByb3ZpZGVyVG9GYWN0b3J5KG1vZHVsZVR5cGUsIHsgdXNlQ2xhc3M6IG1vZHVsZVR5cGUgfSksXHJcbiAgICAgICAgcHJvdmlkZXJzOiBtZXRhZGF0YSAmJiBtZXRhZGF0YS5wcm92aWRlcnMsXHJcbiAgICAgICAgaW1wb3J0czogaW1wb3J0cyxcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydCB2YXIgU1dJVENIX0NPTVBJTEVfTkdNT0RVTEVfX1BPU1RfUjNfXyA9IHJlbmRlcjNDb21waWxlTmdNb2R1bGU7XHJcbnZhciBTV0lUQ0hfQ09NUElMRV9OR01PRFVMRV9fUFJFX1IzX18gPSBwcmVSM05nTW9kdWxlQ29tcGlsZTtcclxudmFyIFNXSVRDSF9DT01QSUxFX05HTU9EVUxFID0gU1dJVENIX0NPTVBJTEVfTkdNT0RVTEVfX1BSRV9SM19fO1xyXG5leHBvcnQgeyDJtTAsIMm1MSB9O1xyIl19