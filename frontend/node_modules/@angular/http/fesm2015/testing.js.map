{"version":3,"sources":["d:/Projects/TestProject/Charging/Charging/frontend/node_modules/@angular/http/fesm2015/testing.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0LC,qMAGC","file":"testing.js","sourcesContent":["/**\r\n * @license Angular v7.2.15\r\n * (c) 2010-2019 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\nimport { Injectable } from '@angular/core';\r\nimport { ReadyState, Request } from '@angular/http';\r\nimport { ReplaySubject, Subject } from 'rxjs';\r\nimport { take } from 'rxjs/operators';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n *\r\n * Mock Connection to represent a {\\@link Connection} for tests.\r\n *\r\n * \\@usageNotes\r\n * ### Example of `mockRespond()`\r\n *\r\n * ```\r\n * var connection;\r\n * backend.connections.subscribe(c => connection = c);\r\n * http.request('data.json').subscribe(res => console.log(res.text()));\r\n * connection.mockRespond(new Response(new ResponseOptions({ body: 'fake response' }))); //logs\r\n * 'fake response'\r\n * ```\r\n *\r\n * ### Example of `mockError()`\r\n *\r\n * ```\r\n * var connection;\r\n * backend.connections.subscribe(c => connection = c);\r\n * http.request('data.json').subscribe(res => res, err => console.log(err)));\r\n * connection.mockError(new Error('error'));\r\n * ```\r\n *\r\n * @deprecated see https://angular.io/guide/http\r\n * \\@publicApi\r\n */\r\nclass MockConnection {\r\n    /**\r\n     * @param {?} req\r\n     */\r\n    constructor(req) {\r\n        this.response = (/** @type {?} */ (new ReplaySubject(1).pipe(take(1))));\r\n        this.readyState = ReadyState.Open;\r\n        this.request = req;\r\n    }\r\n    /**\r\n     * Sends a mock response to the connection. This response is the value that is emitted to the\r\n     * {\\@link EventEmitter} returned by {\\@link Http}.\r\n     *\r\n     * @param {?} res\r\n     * @return {?}\r\n     */\r\n    mockRespond(res) {\r\n        if (this.readyState === ReadyState.Done || this.readyState === ReadyState.Cancelled) {\r\n            throw new Error('Connection has already been resolved');\r\n        }\r\n        this.readyState = ReadyState.Done;\r\n        this.response.next(res);\r\n        this.response.complete();\r\n    }\r\n    /**\r\n     * Not yet implemented!\r\n     *\r\n     * Sends the provided {\\@link Response} to the `downloadObserver` of the `Request`\r\n     * associated with this connection.\r\n     * @param {?} res\r\n     * @return {?}\r\n     */\r\n    mockDownload(res) {\r\n        // this.request.downloadObserver.onNext(res);\r\n        // if (res.bytesLoaded === res.totalBytes) {\r\n        //   this.request.downloadObserver.onCompleted();\r\n        // }\r\n    }\r\n    // TODO(jeffbcross): consider using Response type\r\n    /**\r\n     * Emits the provided error object as an error to the {\\@link Response} {\\@link EventEmitter}\r\n     * returned\r\n     * from {\\@link Http}.\r\n     *\r\n     * @param {?=} err\r\n     * @return {?}\r\n     */\r\n    mockError(err) {\r\n        // Matches ResourceLoader semantics\r\n        this.readyState = ReadyState.Done;\r\n        this.response.error(err);\r\n    }\r\n}\r\n/**\r\n * A mock backend for testing the {\\@link Http} service.\r\n *\r\n * This class can be injected in tests, and should be used to override providers\r\n * to other backends, such as {\\@link XHRBackend}.\r\n *\r\n * \\@usageNotes\r\n * ### Example\r\n *\r\n * ```\r\n * import {Injectable, Injector} from '\\@angular/core';\r\n * import {async, fakeAsync, tick} from '\\@angular/core/testing';\r\n * import {BaseRequestOptions, ConnectionBackend, Http, RequestOptions} from '\\@angular/http';\r\n * import {Response, ResponseOptions} from '\\@angular/http';\r\n * import {MockBackend, MockConnection} from '\\@angular/http/testing';\r\n *\r\n * const HERO_ONE = 'HeroNrOne';\r\n * const HERO_TWO = 'WillBeAlwaysTheSecond';\r\n *\r\n * \\@Injectable()\r\n * class HeroService {\r\n *   constructor(private http: Http) {}\r\n *\r\n *   getHeroes(): Promise<String[]> {\r\n *     return this.http.get('myservices.de/api/heroes')\r\n *         .toPromise()\r\n *         .then(response => response.json().data)\r\n *         .catch(e => this.handleError(e));\r\n *   }\r\n *\r\n *   private handleError(error: any): Promise<any> {\r\n *     console.error('An error occurred', error);\r\n *     return Promise.reject(error.message || error);\r\n *   }\r\n * }\r\n *\r\n * describe('MockBackend HeroService Example', () => {\r\n *   beforeEach(() => {\r\n *     this.injector = Injector.create([\r\n *       {provide: ConnectionBackend, useClass: MockBackend},\r\n *       {provide: RequestOptions, useClass: BaseRequestOptions},\r\n *       Http,\r\n *       HeroService,\r\n *     ]);\r\n *     this.heroService = this.injector.get(HeroService);\r\n *     this.backend = this.injector.get(ConnectionBackend) as MockBackend;\r\n *     this.backend.connections.subscribe((connection: any) => this.lastConnection = connection);\r\n *   });\r\n *\r\n *   it('getHeroes() should query current service url', () => {\r\n *     this.heroService.getHeroes();\r\n *     expect(this.lastConnection).toBeDefined('no http service connection at all?');\r\n *     expect(this.lastConnection.request.url).toMatch(/api\\/heroes$/, 'url invalid');\r\n *   });\r\n *\r\n *   it('getHeroes() should return some heroes', fakeAsync(() => {\r\n *        let result: String[];\r\n *        this.heroService.getHeroes().then((heroes: String[]) => result = heroes);\r\n *        this.lastConnection.mockRespond(new Response(new ResponseOptions({\r\n *          body: JSON.stringify({data: [HERO_ONE, HERO_TWO]}),\r\n *        })));\r\n *        tick();\r\n *        expect(result.length).toEqual(2, 'should contain given amount of heroes');\r\n *        expect(result[0]).toEqual(HERO_ONE, ' HERO_ONE should be the first hero');\r\n *        expect(result[1]).toEqual(HERO_TWO, ' HERO_TWO should be the second hero');\r\n *      }));\r\n *\r\n *   it('getHeroes() while server is down', fakeAsync(() => {\r\n *        let result: String[];\r\n *        let catchedError: any;\r\n *        this.heroService.getHeroes()\r\n *            .then((heroes: String[]) => result = heroes)\r\n *            .catch((error: any) => catchedError = error);\r\n *        this.lastConnection.mockError(new Response(new ResponseOptions({\r\n *          status: 404,\r\n *          statusText: 'URL not Found',\r\n *        })));\r\n *        tick();\r\n *        expect(result).toBeUndefined();\r\n *        expect(catchedError).toBeDefined();\r\n *      }));\r\n * });\r\n * ```\r\n *\r\n * @deprecated see https://angular.io/guide/http\r\n * \\@publicApi\r\n */\r\nclass MockBackend {\r\n    // Subject<MockConnection>\r\n    constructor() {\r\n        this.connectionsArray = [];\r\n        this.connections = new Subject();\r\n        this.connections.subscribe((connection) => this.connectionsArray.push(connection));\r\n        this.pendingConnections = new Subject();\r\n    }\r\n    /**\r\n     * Checks all connections, and raises an exception if any connection has not received a response.\r\n     *\r\n     * This method only exists in the mock implementation, not in real Backends.\r\n     * @return {?}\r\n     */\r\n    verifyNoPendingRequests() {\r\n        /** @type {?} */\r\n        let pending = 0;\r\n        this.pendingConnections.subscribe((c) => pending++);\r\n        if (pending > 0)\r\n            throw new Error(`${pending} pending connections to be resolved`);\r\n    }\r\n    /**\r\n     * Can be used in conjunction with `verifyNoPendingRequests` to resolve any not-yet-resolve\r\n     * connections, if it's expected that there are connections that have not yet received a response.\r\n     *\r\n     * This method only exists in the mock implementation, not in real Backends.\r\n     * @return {?}\r\n     */\r\n    resolveAllConnections() { this.connections.subscribe((c) => c.readyState = 4); }\r\n    /**\r\n     * Creates a new {\\@link MockConnection}. This is equivalent to calling `new\r\n     * MockConnection()`, except that it also will emit the new `Connection` to the `connections`\r\n     * emitter of this `MockBackend` instance. This method will usually only be used by tests\r\n     * against the framework itself, not by end-users.\r\n     * @param {?} req\r\n     * @return {?}\r\n     */\r\n    createConnection(req) {\r\n        if (!req || !(req instanceof Request)) {\r\n            throw new Error(`createConnection requires an instance of Request, got ${req}`);\r\n        }\r\n        /** @type {?} */\r\n        const connection = new MockConnection(req);\r\n        this.connections.next(connection);\r\n        return connection;\r\n    }\r\n}\r\nMockBackend.decorators = [\r\n    { type: Injectable }\r\n];\r\n/** @nocollapse */\r\nMockBackend.ctorParameters = () => [];\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { MockConnection, MockBackend };\r\n\r\n"]}