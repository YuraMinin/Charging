/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { ɵgetDOM as getDOM } from '@angular/platform-browser';
import { Observable } from 'rxjs';
import { ResponseOptions } from '../base_response_options';
import { ContentType, RequestMethod, ResponseContentType, ResponseType } from '../enums';
import { Headers } from '../headers';
import { getResponseURL, isSuccess } from '../http_utils';
import { XSRFStrategy } from '../interfaces';
import { Response } from '../static_response';
import { BrowserXhr } from './browser_xhr';
import * as ɵngcc0 from '@angular/core';
var XSSI_PREFIX = /^\)\]\}',?\n/;
/**
 * Creates connections using `XMLHttpRequest`. Given a fully-qualified
 * request, an `XHRConnection` will immediately create an `XMLHttpRequest` object and send the
 * request.
 *
 * This class would typically not be created or interacted with directly inside applications, though
 * the {@link MockConnection} may be interacted with in tests.
 *
 * @deprecated see https://angular.io/guide/http
 * @publicApi
 */
var XHRConnection = /** @class */ (function () {
    function XHRConnection(req, browserXHR, baseResponseOptions) {
        var _this = this;
        this.request = req;
        this.response = new Observable(function (responseObserver) {
            var _xhr = browserXHR.build();
            _xhr.open(RequestMethod[req.method].toUpperCase(), req.url);
            if (req.withCredentials != null) {
                _xhr.withCredentials = req.withCredentials;
            }
            // load event handler
            var onLoad = function () {
                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
                var status = _xhr.status === 1223 ? 204 : _xhr.status;
                var body = null;
                // HTTP 204 means no content
                if (status !== 204) {
                    // responseText is the old-school way of retrieving response (supported by IE8 & 9)
                    // response/responseType properties were introduced in ResourceLoader Level2 spec
                    // (supported by IE10)
                    body = (typeof _xhr.response === 'undefined') ? _xhr.responseText : _xhr.response;
                    // Implicitly strip a potential XSSI prefix.
                    if (typeof body === 'string') {
                        body = body.replace(XSSI_PREFIX, '');
                    }
                }
                // fix status code when it is 0 (0 status is undocumented).
                // Occurs when accessing file resources or on Android 4.1 stock browser
                // while retrieving files from application cache.
                if (status === 0) {
                    status = body ? 200 : 0;
                }
                var headers = Headers.fromResponseHeaderString(_xhr.getAllResponseHeaders());
                // IE 9 does not provide the way to get URL of response
                var url = getResponseURL(_xhr) || req.url;
                var statusText = _xhr.statusText || 'OK';
                var responseOptions = new ResponseOptions({ body: body, status: status, headers: headers, statusText: statusText, url: url });
                if (baseResponseOptions != null) {
                    responseOptions = baseResponseOptions.merge(responseOptions);
                }
                var response = new Response(responseOptions);
                response.ok = isSuccess(status);
                if (response.ok) {
                    responseObserver.next(response);
                    // TODO(gdi2290): defer complete if array buffer until done
                    responseObserver.complete();
                    return;
                }
                responseObserver.error(response);
            };
            // error event handler
            var onError = function (err) {
                var responseOptions = new ResponseOptions({
                    body: err,
                    type: ResponseType.Error,
                    status: _xhr.status,
                    statusText: _xhr.statusText,
                });
                if (baseResponseOptions != null) {
                    responseOptions = baseResponseOptions.merge(responseOptions);
                }
                responseObserver.error(new Response(responseOptions));
            };
            _this.setDetectedContentType(req, _xhr);
            if (req.headers == null) {
                req.headers = new Headers();
            }
            if (!req.headers.has('Accept')) {
                req.headers.append('Accept', 'application/json, text/plain, */*');
            }
            req.headers.forEach(function (values, name) { return _xhr.setRequestHeader(name, values.join(',')); });
            // Select the correct buffer type to store the response
            if (req.responseType != null && _xhr.responseType != null) {
                switch (req.responseType) {
                    case ResponseContentType.ArrayBuffer:
                        _xhr.responseType = 'arraybuffer';
                        break;
                    case ResponseContentType.Json:
                        _xhr.responseType = 'json';
                        break;
                    case ResponseContentType.Text:
                        _xhr.responseType = 'text';
                        break;
                    case ResponseContentType.Blob:
                        _xhr.responseType = 'blob';
                        break;
                    default:
                        throw new Error('The selected responseType is not supported');
                }
            }
            _xhr.addEventListener('load', onLoad);
            _xhr.addEventListener('error', onError);
            _xhr.send(_this.request.getBody());
            return function () {
                _xhr.removeEventListener('load', onLoad);
                _xhr.removeEventListener('error', onError);
                _xhr.abort();
            };
        });
    }
    XHRConnection.prototype.setDetectedContentType = function (req /** TODO Request */, _xhr /** XMLHttpRequest */) {
        // Skip if a custom Content-Type header is provided
        if (req.headers != null && req.headers.get('Content-Type') != null) {
            return;
        }
        // Set the detected content type
        switch (req.contentType) {
            case ContentType.NONE:
                break;
            case ContentType.JSON:
                _xhr.setRequestHeader('content-type', 'application/json');
                break;
            case ContentType.FORM:
                _xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
                break;
            case ContentType.TEXT:
                _xhr.setRequestHeader('content-type', 'text/plain');
                break;
            case ContentType.BLOB:
                var blob = req.blob();
                if (blob.type) {
                    _xhr.setRequestHeader('content-type', blob.type);
                }
                break;
        }
    };
    return XHRConnection;
}());
export { XHRConnection };
/**
 * `XSRFConfiguration` sets up Cross Site Request Forgery (XSRF) protection for the application
 * using a cookie. See https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)
 * for more information on XSRF.
 *
 * Applications can configure custom cookie and header names by binding an instance of this class
 * with different `cookieName` and `headerName` values. See the main HTTP documentation for more
 * details.
 *
 * @deprecated see https://angular.io/guide/http
 * @publicApi
 */
var CookieXSRFStrategy = /** @class */ (function () {
    function CookieXSRFStrategy(_cookieName, _headerName) {
        if (_cookieName === void 0) { _cookieName = 'XSRF-TOKEN'; }
        if (_headerName === void 0) { _headerName = 'X-XSRF-TOKEN'; }
        this._cookieName = _cookieName;
        this._headerName = _headerName;
    }
    CookieXSRFStrategy.prototype.configureRequest = function (req) {
        var xsrfToken = getDOM().getCookie(this._cookieName);
        if (xsrfToken) {
            req.headers.set(this._headerName, xsrfToken);
        }
    };
    return CookieXSRFStrategy;
}());
export { CookieXSRFStrategy };
/**
 * Creates {@link XHRConnection} instances.
 *
 * This class would typically not be used by end users, but could be
 * overridden if a different backend implementation should be used,
 * such as in a node backend.
 *
 * @usageNotes
 * ### Example
 *
 * ```
 * import {Http, MyNodeBackend, HTTP_PROVIDERS, BaseRequestOptions} from '@angular/http';
 * @Component({
 *   viewProviders: [
 *     HTTP_PROVIDERS,
 *     {provide: Http, useFactory: (backend, options) => {
 *       return new Http(backend, options);
 *     }, deps: [MyNodeBackend, BaseRequestOptions]}]
 * })
 * class MyComponent {
 *   constructor(http:Http) {
 *     http.request('people.json').subscribe(res => this.people = res.json());
 *   }
 * }
 * ```
 * @deprecated see https://angular.io/guide/http
 * @publicApi
 */
var XHRBackend = /** @class */ (function () {
    function XHRBackend(_browserXHR, _baseResponseOptions, _xsrfStrategy) {
        this._browserXHR = _browserXHR;
        this._baseResponseOptions = _baseResponseOptions;
        this._xsrfStrategy = _xsrfStrategy;
    }
    XHRBackend.prototype.createConnection = function (request) {
        this._xsrfStrategy.configureRequest(request);
        return new XHRConnection(request, this._browserXHR, this._baseResponseOptions);
    };
    XHRBackend = tslib_1.__decorate([
        tslib_1.__metadata("design:paramtypes", [BrowserXhr, ResponseOptions,
            XSRFStrategy])
    ], XHRBackend);
XHRBackend.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: XHRBackend, factory: function XHRBackend_Factory(t) { return new (t || XHRBackend)(ɵngcc0.ɵɵinject(BrowserXhr), ɵngcc0.ɵɵinject(ResponseOptions), ɵngcc0.ɵɵinject(XSRFStrategy)); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(XHRBackend, [{
        type: Injectable
    }], function () { return [{ type: BrowserXhr }, { type: ResponseOptions }, { type: XSRFStrategy }]; }, { _browserXHR: [], _baseResponseOptions: [], _xsrfStrategy: [], createConnection: [] });
    return XHRBackend;
}());
export { XHRBackend };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L1Byb2plY3RzL1Rlc3RQcm9qZWN0L0NoYXJnaW5nL0NoYXJnaW5nL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AYW5ndWxhci9odHRwL2VzbTUvc3JjL2JhY2tlbmRzL3hocl9iYWNrZW5kLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUNBK01xQyxBQUNoQjs7Ozs7OzttTUFHRiIsImZpbGUiOiJ4aHJfYmFja2VuZC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyDJtWdldERPTSBhcyBnZXRET00gfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBSZXNwb25zZU9wdGlvbnMgfSBmcm9tICcuLi9iYXNlX3Jlc3BvbnNlX29wdGlvbnMnO1xyXG5pbXBvcnQgeyBDb250ZW50VHlwZSwgUmVxdWVzdE1ldGhvZCwgUmVzcG9uc2VDb250ZW50VHlwZSwgUmVzcG9uc2VUeXBlIH0gZnJvbSAnLi4vZW51bXMnO1xyXG5pbXBvcnQgeyBIZWFkZXJzIH0gZnJvbSAnLi4vaGVhZGVycyc7XHJcbmltcG9ydCB7IGdldFJlc3BvbnNlVVJMLCBpc1N1Y2Nlc3MgfSBmcm9tICcuLi9odHRwX3V0aWxzJztcclxuaW1wb3J0IHsgWFNSRlN0cmF0ZWd5IH0gZnJvbSAnLi4vaW50ZXJmYWNlcyc7XHJcbmltcG9ydCB7IFJlc3BvbnNlIH0gZnJvbSAnLi4vc3RhdGljX3Jlc3BvbnNlJztcclxuaW1wb3J0IHsgQnJvd3NlclhociB9IGZyb20gJy4vYnJvd3Nlcl94aHInO1xyXG52YXIgWFNTSV9QUkVGSVggPSAvXlxcKVxcXVxcfScsP1xcbi87XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGNvbm5lY3Rpb25zIHVzaW5nIGBYTUxIdHRwUmVxdWVzdGAuIEdpdmVuIGEgZnVsbHktcXVhbGlmaWVkXHJcbiAqIHJlcXVlc3QsIGFuIGBYSFJDb25uZWN0aW9uYCB3aWxsIGltbWVkaWF0ZWx5IGNyZWF0ZSBhbiBgWE1MSHR0cFJlcXVlc3RgIG9iamVjdCBhbmQgc2VuZCB0aGVcclxuICogcmVxdWVzdC5cclxuICpcclxuICogVGhpcyBjbGFzcyB3b3VsZCB0eXBpY2FsbHkgbm90IGJlIGNyZWF0ZWQgb3IgaW50ZXJhY3RlZCB3aXRoIGRpcmVjdGx5IGluc2lkZSBhcHBsaWNhdGlvbnMsIHRob3VnaFxyXG4gKiB0aGUge0BsaW5rIE1vY2tDb25uZWN0aW9ufSBtYXkgYmUgaW50ZXJhY3RlZCB3aXRoIGluIHRlc3RzLlxyXG4gKlxyXG4gKiBAZGVwcmVjYXRlZCBzZWUgaHR0cHM6Ly9hbmd1bGFyLmlvL2d1aWRlL2h0dHBcclxuICogQHB1YmxpY0FwaVxyXG4gKi9cclxudmFyIFhIUkNvbm5lY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBYSFJDb25uZWN0aW9uKHJlcSwgYnJvd3NlclhIUiwgYmFzZVJlc3BvbnNlT3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVxO1xyXG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAocmVzcG9uc2VPYnNlcnZlcikge1xyXG4gICAgICAgICAgICB2YXIgX3hociA9IGJyb3dzZXJYSFIuYnVpbGQoKTtcclxuICAgICAgICAgICAgX3hoci5vcGVuKFJlcXVlc3RNZXRob2RbcmVxLm1ldGhvZF0udG9VcHBlckNhc2UoKSwgcmVxLnVybCk7XHJcbiAgICAgICAgICAgIGlmIChyZXEud2l0aENyZWRlbnRpYWxzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIF94aHIud2l0aENyZWRlbnRpYWxzID0gcmVxLndpdGhDcmVkZW50aWFscztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBsb2FkIGV2ZW50IGhhbmRsZXJcclxuICAgICAgICAgICAgdmFyIG9uTG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBJRTkgYnVnIChodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwKVxyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IF94aHIuc3RhdHVzID09PSAxMjIzID8gMjA0IDogX3hoci5zdGF0dXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9keSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAvLyBIVFRQIDIwNCBtZWFucyBubyBjb250ZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzICE9PSAyMDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXNwb25zZVRleHQgaXMgdGhlIG9sZC1zY2hvb2wgd2F5IG9mIHJldHJpZXZpbmcgcmVzcG9uc2UgKHN1cHBvcnRlZCBieSBJRTggJiA5KVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc3BvbnNlL3Jlc3BvbnNlVHlwZSBwcm9wZXJ0aWVzIHdlcmUgaW50cm9kdWNlZCBpbiBSZXNvdXJjZUxvYWRlciBMZXZlbDIgc3BlY1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIChzdXBwb3J0ZWQgYnkgSUUxMClcclxuICAgICAgICAgICAgICAgICAgICBib2R5ID0gKHR5cGVvZiBfeGhyLnJlc3BvbnNlID09PSAndW5kZWZpbmVkJykgPyBfeGhyLnJlc3BvbnNlVGV4dCA6IF94aHIucmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW1wbGljaXRseSBzdHJpcCBhIHBvdGVudGlhbCBYU1NJIHByZWZpeC5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5LnJlcGxhY2UoWFNTSV9QUkVGSVgsICcnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBmaXggc3RhdHVzIGNvZGUgd2hlbiBpdCBpcyAwICgwIHN0YXR1cyBpcyB1bmRvY3VtZW50ZWQpLlxyXG4gICAgICAgICAgICAgICAgLy8gT2NjdXJzIHdoZW4gYWNjZXNzaW5nIGZpbGUgcmVzb3VyY2VzIG9yIG9uIEFuZHJvaWQgNC4xIHN0b2NrIGJyb3dzZXJcclxuICAgICAgICAgICAgICAgIC8vIHdoaWxlIHJldHJpZXZpbmcgZmlsZXMgZnJvbSBhcHBsaWNhdGlvbiBjYWNoZS5cclxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSBib2R5ID8gMjAwIDogMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBoZWFkZXJzID0gSGVhZGVycy5mcm9tUmVzcG9uc2VIZWFkZXJTdHJpbmcoX3hoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSk7XHJcbiAgICAgICAgICAgICAgICAvLyBJRSA5IGRvZXMgbm90IHByb3ZpZGUgdGhlIHdheSB0byBnZXQgVVJMIG9mIHJlc3BvbnNlXHJcbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gZ2V0UmVzcG9uc2VVUkwoX3hocikgfHwgcmVxLnVybDtcclxuICAgICAgICAgICAgICAgIHZhciBzdGF0dXNUZXh0ID0gX3hoci5zdGF0dXNUZXh0IHx8ICdPSyc7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VPcHRpb25zID0gbmV3IFJlc3BvbnNlT3B0aW9ucyh7IGJvZHk6IGJvZHksIHN0YXR1czogc3RhdHVzLCBoZWFkZXJzOiBoZWFkZXJzLCBzdGF0dXNUZXh0OiBzdGF0dXNUZXh0LCB1cmw6IHVybCB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChiYXNlUmVzcG9uc2VPcHRpb25zICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZU9wdGlvbnMgPSBiYXNlUmVzcG9uc2VPcHRpb25zLm1lcmdlKHJlc3BvbnNlT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UocmVzcG9uc2VPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLm9rID0gaXNTdWNjZXNzKHN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZU9ic2VydmVyLm5leHQocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8oZ2RpMjI5MCk6IGRlZmVyIGNvbXBsZXRlIGlmIGFycmF5IGJ1ZmZlciB1bnRpbCBkb25lXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VPYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlT2JzZXJ2ZXIuZXJyb3IocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBlcnJvciBldmVudCBoYW5kbGVyXHJcbiAgICAgICAgICAgIHZhciBvbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlT3B0aW9ucyA9IG5ldyBSZXNwb25zZU9wdGlvbnMoe1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IGVycixcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBSZXNwb25zZVR5cGUuRXJyb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBfeGhyLnN0YXR1cyxcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiBfeGhyLnN0YXR1c1RleHQsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChiYXNlUmVzcG9uc2VPcHRpb25zICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZU9wdGlvbnMgPSBiYXNlUmVzcG9uc2VPcHRpb25zLm1lcmdlKHJlc3BvbnNlT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXNwb25zZU9ic2VydmVyLmVycm9yKG5ldyBSZXNwb25zZShyZXNwb25zZU9wdGlvbnMpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgX3RoaXMuc2V0RGV0ZWN0ZWRDb250ZW50VHlwZShyZXEsIF94aHIpO1xyXG4gICAgICAgICAgICBpZiAocmVxLmhlYWRlcnMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmVxLmhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghcmVxLmhlYWRlcnMuaGFzKCdBY2NlcHQnKSkge1xyXG4gICAgICAgICAgICAgICAgcmVxLmhlYWRlcnMuYXBwZW5kKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVxLmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWVzLCBuYW1lKSB7IHJldHVybiBfeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWVzLmpvaW4oJywnKSk7IH0pO1xyXG4gICAgICAgICAgICAvLyBTZWxlY3QgdGhlIGNvcnJlY3QgYnVmZmVyIHR5cGUgdG8gc3RvcmUgdGhlIHJlc3BvbnNlXHJcbiAgICAgICAgICAgIGlmIChyZXEucmVzcG9uc2VUeXBlICE9IG51bGwgJiYgX3hoci5yZXNwb25zZVR5cGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChyZXEucmVzcG9uc2VUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXNwb25zZUNvbnRlbnRUeXBlLkFycmF5QnVmZmVyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUmVzcG9uc2VDb250ZW50VHlwZS5Kc29uOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXNwb25zZUNvbnRlbnRUeXBlLlRleHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF94aHIucmVzcG9uc2VUeXBlID0gJ3RleHQnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFJlc3BvbnNlQ29udGVudFR5cGUuQmxvYjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3hoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNlbGVjdGVkIHJlc3BvbnNlVHlwZSBpcyBub3Qgc3VwcG9ydGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3hoci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcclxuICAgICAgICAgICAgX3hoci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xyXG4gICAgICAgICAgICBfeGhyLnNlbmQoX3RoaXMucmVxdWVzdC5nZXRCb2R5KCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3hoci5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcclxuICAgICAgICAgICAgICAgIF94aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcclxuICAgICAgICAgICAgICAgIF94aHIuYWJvcnQoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIFhIUkNvbm5lY3Rpb24ucHJvdG90eXBlLnNldERldGVjdGVkQ29udGVudFR5cGUgPSBmdW5jdGlvbiAocmVxIC8qKiBUT0RPIFJlcXVlc3QgKi8sIF94aHIgLyoqIFhNTEh0dHBSZXF1ZXN0ICovKSB7XHJcbiAgICAgICAgLy8gU2tpcCBpZiBhIGN1c3RvbSBDb250ZW50LVR5cGUgaGVhZGVyIGlzIHByb3ZpZGVkXHJcbiAgICAgICAgaWYgKHJlcS5oZWFkZXJzICE9IG51bGwgJiYgcmVxLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2V0IHRoZSBkZXRlY3RlZCBjb250ZW50IHR5cGVcclxuICAgICAgICBzd2l0Y2ggKHJlcS5jb250ZW50VHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIENvbnRlbnRUeXBlLk5PTkU6XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBDb250ZW50VHlwZS5KU09OOlxyXG4gICAgICAgICAgICAgICAgX3hoci5zZXRSZXF1ZXN0SGVhZGVyKCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgQ29udGVudFR5cGUuRk9STTpcclxuICAgICAgICAgICAgICAgIF94aHIuc2V0UmVxdWVzdEhlYWRlcignY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBDb250ZW50VHlwZS5URVhUOlxyXG4gICAgICAgICAgICAgICAgX3hoci5zZXRSZXF1ZXN0SGVhZGVyKCdjb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbicpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgQ29udGVudFR5cGUuQkxPQjpcclxuICAgICAgICAgICAgICAgIHZhciBibG9iID0gcmVxLmJsb2IoKTtcclxuICAgICAgICAgICAgICAgIGlmIChibG9iLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBfeGhyLnNldFJlcXVlc3RIZWFkZXIoJ2NvbnRlbnQtdHlwZScsIGJsb2IudHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFhIUkNvbm5lY3Rpb247XHJcbn0oKSk7XHJcbmV4cG9ydCB7IFhIUkNvbm5lY3Rpb24gfTtcclxuLyoqXHJcbiAqIGBYU1JGQ29uZmlndXJhdGlvbmAgc2V0cyB1cCBDcm9zcyBTaXRlIFJlcXVlc3QgRm9yZ2VyeSAoWFNSRikgcHJvdGVjdGlvbiBmb3IgdGhlIGFwcGxpY2F0aW9uXHJcbiAqIHVzaW5nIGEgY29va2llLiBTZWUgaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9Dcm9zcy1TaXRlX1JlcXVlc3RfRm9yZ2VyeV8oQ1NSRilcclxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gWFNSRi5cclxuICpcclxuICogQXBwbGljYXRpb25zIGNhbiBjb25maWd1cmUgY3VzdG9tIGNvb2tpZSBhbmQgaGVhZGVyIG5hbWVzIGJ5IGJpbmRpbmcgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzc1xyXG4gKiB3aXRoIGRpZmZlcmVudCBgY29va2llTmFtZWAgYW5kIGBoZWFkZXJOYW1lYCB2YWx1ZXMuIFNlZSB0aGUgbWFpbiBIVFRQIGRvY3VtZW50YXRpb24gZm9yIG1vcmVcclxuICogZGV0YWlscy5cclxuICpcclxuICogQGRlcHJlY2F0ZWQgc2VlIGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS9odHRwXHJcbiAqIEBwdWJsaWNBcGlcclxuICovXHJcbnZhciBDb29raWVYU1JGU3RyYXRlZ3kgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb29raWVYU1JGU3RyYXRlZ3koX2Nvb2tpZU5hbWUsIF9oZWFkZXJOYW1lKSB7XHJcbiAgICAgICAgaWYgKF9jb29raWVOYW1lID09PSB2b2lkIDApIHsgX2Nvb2tpZU5hbWUgPSAnWFNSRi1UT0tFTic7IH1cclxuICAgICAgICBpZiAoX2hlYWRlck5hbWUgPT09IHZvaWQgMCkgeyBfaGVhZGVyTmFtZSA9ICdYLVhTUkYtVE9LRU4nOyB9XHJcbiAgICAgICAgdGhpcy5fY29va2llTmFtZSA9IF9jb29raWVOYW1lO1xyXG4gICAgICAgIHRoaXMuX2hlYWRlck5hbWUgPSBfaGVhZGVyTmFtZTtcclxuICAgIH1cclxuICAgIENvb2tpZVhTUkZTdHJhdGVneS5wcm90b3R5cGUuY29uZmlndXJlUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXEpIHtcclxuICAgICAgICB2YXIgeHNyZlRva2VuID0gZ2V0RE9NKCkuZ2V0Q29va2llKHRoaXMuX2Nvb2tpZU5hbWUpO1xyXG4gICAgICAgIGlmICh4c3JmVG9rZW4pIHtcclxuICAgICAgICAgICAgcmVxLmhlYWRlcnMuc2V0KHRoaXMuX2hlYWRlck5hbWUsIHhzcmZUb2tlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBDb29raWVYU1JGU3RyYXRlZ3k7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IENvb2tpZVhTUkZTdHJhdGVneSB9O1xyXG4vKipcclxuICogQ3JlYXRlcyB7QGxpbmsgWEhSQ29ubmVjdGlvbn0gaW5zdGFuY2VzLlxyXG4gKlxyXG4gKiBUaGlzIGNsYXNzIHdvdWxkIHR5cGljYWxseSBub3QgYmUgdXNlZCBieSBlbmQgdXNlcnMsIGJ1dCBjb3VsZCBiZVxyXG4gKiBvdmVycmlkZGVuIGlmIGEgZGlmZmVyZW50IGJhY2tlbmQgaW1wbGVtZW50YXRpb24gc2hvdWxkIGJlIHVzZWQsXHJcbiAqIHN1Y2ggYXMgaW4gYSBub2RlIGJhY2tlbmQuXHJcbiAqXHJcbiAqIEB1c2FnZU5vdGVzXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBpbXBvcnQge0h0dHAsIE15Tm9kZUJhY2tlbmQsIEhUVFBfUFJPVklERVJTLCBCYXNlUmVxdWVzdE9wdGlvbnN9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xyXG4gKiBAQ29tcG9uZW50KHtcclxuICogICB2aWV3UHJvdmlkZXJzOiBbXHJcbiAqICAgICBIVFRQX1BST1ZJREVSUyxcclxuICogICAgIHtwcm92aWRlOiBIdHRwLCB1c2VGYWN0b3J5OiAoYmFja2VuZCwgb3B0aW9ucykgPT4ge1xyXG4gKiAgICAgICByZXR1cm4gbmV3IEh0dHAoYmFja2VuZCwgb3B0aW9ucyk7XHJcbiAqICAgICB9LCBkZXBzOiBbTXlOb2RlQmFja2VuZCwgQmFzZVJlcXVlc3RPcHRpb25zXX1dXHJcbiAqIH0pXHJcbiAqIGNsYXNzIE15Q29tcG9uZW50IHtcclxuICogICBjb25zdHJ1Y3RvcihodHRwOkh0dHApIHtcclxuICogICAgIGh0dHAucmVxdWVzdCgncGVvcGxlLmpzb24nKS5zdWJzY3JpYmUocmVzID0+IHRoaXMucGVvcGxlID0gcmVzLmpzb24oKSk7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKiBAZGVwcmVjYXRlZCBzZWUgaHR0cHM6Ly9hbmd1bGFyLmlvL2d1aWRlL2h0dHBcclxuICogQHB1YmxpY0FwaVxyXG4gKi9cclxudmFyIFhIUkJhY2tlbmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBYSFJCYWNrZW5kKF9icm93c2VyWEhSLCBfYmFzZVJlc3BvbnNlT3B0aW9ucywgX3hzcmZTdHJhdGVneSkge1xyXG4gICAgICAgIHRoaXMuX2Jyb3dzZXJYSFIgPSBfYnJvd3NlclhIUjtcclxuICAgICAgICB0aGlzLl9iYXNlUmVzcG9uc2VPcHRpb25zID0gX2Jhc2VSZXNwb25zZU9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5feHNyZlN0cmF0ZWd5ID0gX3hzcmZTdHJhdGVneTtcclxuICAgIH1cclxuICAgIFhIUkJhY2tlbmQucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbiAocmVxdWVzdCkge1xyXG4gICAgICAgIHRoaXMuX3hzcmZTdHJhdGVneS5jb25maWd1cmVSZXF1ZXN0KHJlcXVlc3QpO1xyXG4gICAgICAgIHJldHVybiBuZXcgWEhSQ29ubmVjdGlvbihyZXF1ZXN0LCB0aGlzLl9icm93c2VyWEhSLCB0aGlzLl9iYXNlUmVzcG9uc2VPcHRpb25zKTtcclxuICAgIH07XHJcbiAgICBYSFJCYWNrZW5kID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgICAgICBJbmplY3RhYmxlKCksXHJcbiAgICAgICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jyb3dzZXJYaHIsIFJlc3BvbnNlT3B0aW9ucyxcclxuICAgICAgICAgICAgWFNSRlN0cmF0ZWd5XSlcclxuICAgIF0sIFhIUkJhY2tlbmQpO1xyXG4gICAgcmV0dXJuIFhIUkJhY2tlbmQ7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IFhIUkJhY2tlbmQgfTtcciJdfQ==