/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as tslib_1 from "tslib";
import { DOCUMENT } from '@angular/common';
import { APP_ID, Injectable, NgModule } from '@angular/core';
import * as ɵngcc0 from '@angular/core';
export function escapeHtml(text) {
    var escapedText = {
        '&': '&a;',
        '"': '&q;',
        '\'': '&s;',
        '<': '&l;',
        '>': '&g;',
    };
    return text.replace(/[&"'<>]/g, function (s) { return escapedText[s]; });
}
export function unescapeHtml(text) {
    var unescapedText = {
        '&a;': '&',
        '&q;': '"',
        '&s;': '\'',
        '&l;': '<',
        '&g;': '>',
    };
    return text.replace(/&[^;]+;/g, function (s) { return unescapedText[s]; });
}
/**
 * Create a `StateKey<T>` that can be used to store value of type T with `TransferState`.
 *
 * Example:
 *
 * ```
 * const COUNTER_KEY = makeStateKey<number>('counter');
 * let value = 10;
 *
 * transferState.set(COUNTER_KEY, value);
 * ```
 *
 * @publicApi
 */
export function makeStateKey(key) {
    return key;
}
/**
 * A key value store that is transferred from the application on the server side to the application
 * on the client side.
 *
 * `TransferState` will be available as an injectable token. To use it import
 * `ServerTransferStateModule` on the server and `BrowserTransferStateModule` on the client.
 *
 * The values in the store are serialized/deserialized using JSON.stringify/JSON.parse. So only
 * boolean, number, string, null and non-class objects will be serialized and deserialzied in a
 * non-lossy manner.
 *
 * @publicApi
 */
var TransferState = /** @class */ (function () {
    function TransferState() {
        this.store = {};
        this.onSerializeCallbacks = {};
    }
    TransferState_1 = TransferState;
    /** @internal */
    TransferState.init = function (initState) {
        var transferState = new TransferState_1();
        transferState.store = initState;
        return transferState;
    };
    /**
     * Get the value corresponding to a key. Return `defaultValue` if key is not found.
     */
    TransferState.prototype.get = function (key, defaultValue) {
        return this.store[key] !== undefined ? this.store[key] : defaultValue;
    };
    /**
     * Set the value corresponding to a key.
     */
    TransferState.prototype.set = function (key, value) { this.store[key] = value; };
    /**
     * Remove a key from the store.
     */
    TransferState.prototype.remove = function (key) { delete this.store[key]; };
    /**
     * Test whether a key exists in the store.
     */
    TransferState.prototype.hasKey = function (key) { return this.store.hasOwnProperty(key); };
    /**
     * Register a callback to provide the value for a key when `toJson` is called.
     */
    TransferState.prototype.onSerialize = function (key, callback) {
        this.onSerializeCallbacks[key] = callback;
    };
    /**
     * Serialize the current state of the store to JSON.
     */
    TransferState.prototype.toJson = function () {
        // Call the onSerialize callbacks and put those values into the store.
        for (var key in this.onSerializeCallbacks) {
            if (this.onSerializeCallbacks.hasOwnProperty(key)) {
                try {
                    this.store[key] = this.onSerializeCallbacks[key]();
                }
                catch (e) {
                    console.warn('Exception in onSerialize callback: ', e);
                }
            }
        }
        return JSON.stringify(this.store);
    };
    var TransferState_1;
TransferState.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: TransferState, factory: function TransferState_Factory(t) { return new (t || TransferState)(); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(TransferState, [{
        type: Injectable
    }], function () { return []; }, { store: [], onSerializeCallbacks: [], get: [], set: [], remove: [], hasKey: [], onSerialize: [], toJson: [] });
    return TransferState;
}());
export { TransferState };
export function initTransferState(doc, appId) {
    // Locate the script tag with the JSON data transferred from the server.
    // The id of the script tag is set to the Angular appId + 'state'.
    var script = doc.getElementById(appId + '-state');
    var initialState = {};
    if (script && script.textContent) {
        try {
            initialState = JSON.parse(unescapeHtml(script.textContent));
        }
        catch (e) {
            console.warn('Exception while restoring TransferState for app ' + appId, e);
        }
    }
    return TransferState.init(initialState);
}
/**
 * NgModule to install on the client side while using the `TransferState` to transfer state from
 * server to client.
 *
 * @publicApi
 */
var BrowserTransferStateModule = /** @class */ (function () {
    function BrowserTransferStateModule() {
    }
BrowserTransferStateModule.ngModuleDef = ɵngcc0.ɵɵdefineNgModule({ type: BrowserTransferStateModule });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(BrowserTransferStateModule, [{
        type: NgModule,
        args: [{
                providers: [{ provide: TransferState, useFactory: initTransferState, deps: [DOCUMENT, APP_ID] }]
            }]
    }], function () { return []; }, null);
BrowserTransferStateModule.ngInjectorDef = ɵngcc0.ɵɵdefineInjector({ factory: function BrowserTransferStateModule_Factory(t) { return new (t || BrowserTransferStateModule)(); }, providers: [{ provide: TransferState, useFactory: initTransferState, deps: [DOCUMENT, APP_ID] }] });
    return BrowserTransferStateModule;
}());
export { BrowserTransferStateModule };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L1Byb2plY3RzL1Rlc3RQcm9qZWN0L0NoYXJnaW5nL0NoYXJnaW5nL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL2VzbTUvc3JjL2Jyb3dzZXIvdHJhbnNmZXJfc3RhdGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7O0FBVUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0JBdUd3Qjs7OztvSkFHRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBMkJqQjs7Ozs7Ozs7c1JBSzhCIiwiZmlsZSI6InRyYW5zZmVyX3N0YXRlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IEFQUF9JRCwgSW5qZWN0YWJsZSwgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUh0bWwodGV4dCkge1xyXG4gICAgdmFyIGVzY2FwZWRUZXh0ID0ge1xyXG4gICAgICAgICcmJzogJyZhOycsXHJcbiAgICAgICAgJ1wiJzogJyZxOycsXHJcbiAgICAgICAgJ1xcJyc6ICcmczsnLFxyXG4gICAgICAgICc8JzogJyZsOycsXHJcbiAgICAgICAgJz4nOiAnJmc7JyxcclxuICAgIH07XHJcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9bJlwiJzw+XS9nLCBmdW5jdGlvbiAocykgeyByZXR1cm4gZXNjYXBlZFRleHRbc107IH0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB1bmVzY2FwZUh0bWwodGV4dCkge1xyXG4gICAgdmFyIHVuZXNjYXBlZFRleHQgPSB7XHJcbiAgICAgICAgJyZhOyc6ICcmJyxcclxuICAgICAgICAnJnE7JzogJ1wiJyxcclxuICAgICAgICAnJnM7JzogJ1xcJycsXHJcbiAgICAgICAgJyZsOyc6ICc8JyxcclxuICAgICAgICAnJmc7JzogJz4nLFxyXG4gICAgfTtcclxuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoLyZbXjtdKzsvZywgZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHVuZXNjYXBlZFRleHRbc107IH0pO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBgU3RhdGVLZXk8VD5gIHRoYXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgdmFsdWUgb2YgdHlwZSBUIHdpdGggYFRyYW5zZmVyU3RhdGVgLlxyXG4gKlxyXG4gKiBFeGFtcGxlOlxyXG4gKlxyXG4gKiBgYGBcclxuICogY29uc3QgQ09VTlRFUl9LRVkgPSBtYWtlU3RhdGVLZXk8bnVtYmVyPignY291bnRlcicpO1xyXG4gKiBsZXQgdmFsdWUgPSAxMDtcclxuICpcclxuICogdHJhbnNmZXJTdGF0ZS5zZXQoQ09VTlRFUl9LRVksIHZhbHVlKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwdWJsaWNBcGlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtYWtlU3RhdGVLZXkoa2V5KSB7XHJcbiAgICByZXR1cm4ga2V5O1xyXG59XHJcbi8qKlxyXG4gKiBBIGtleSB2YWx1ZSBzdG9yZSB0aGF0IGlzIHRyYW5zZmVycmVkIGZyb20gdGhlIGFwcGxpY2F0aW9uIG9uIHRoZSBzZXJ2ZXIgc2lkZSB0byB0aGUgYXBwbGljYXRpb25cclxuICogb24gdGhlIGNsaWVudCBzaWRlLlxyXG4gKlxyXG4gKiBgVHJhbnNmZXJTdGF0ZWAgd2lsbCBiZSBhdmFpbGFibGUgYXMgYW4gaW5qZWN0YWJsZSB0b2tlbi4gVG8gdXNlIGl0IGltcG9ydFxyXG4gKiBgU2VydmVyVHJhbnNmZXJTdGF0ZU1vZHVsZWAgb24gdGhlIHNlcnZlciBhbmQgYEJyb3dzZXJUcmFuc2ZlclN0YXRlTW9kdWxlYCBvbiB0aGUgY2xpZW50LlxyXG4gKlxyXG4gKiBUaGUgdmFsdWVzIGluIHRoZSBzdG9yZSBhcmUgc2VyaWFsaXplZC9kZXNlcmlhbGl6ZWQgdXNpbmcgSlNPTi5zdHJpbmdpZnkvSlNPTi5wYXJzZS4gU28gb25seVxyXG4gKiBib29sZWFuLCBudW1iZXIsIHN0cmluZywgbnVsbCBhbmQgbm9uLWNsYXNzIG9iamVjdHMgd2lsbCBiZSBzZXJpYWxpemVkIGFuZCBkZXNlcmlhbHppZWQgaW4gYVxyXG4gKiBub24tbG9zc3kgbWFubmVyLlxyXG4gKlxyXG4gKiBAcHVibGljQXBpXHJcbiAqL1xyXG52YXIgVHJhbnNmZXJTdGF0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRyYW5zZmVyU3RhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5zdG9yZSA9IHt9O1xyXG4gICAgICAgIHRoaXMub25TZXJpYWxpemVDYWxsYmFja3MgPSB7fTtcclxuICAgIH1cclxuICAgIFRyYW5zZmVyU3RhdGVfMSA9IFRyYW5zZmVyU3RhdGU7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBUcmFuc2ZlclN0YXRlLmluaXQgPSBmdW5jdGlvbiAoaW5pdFN0YXRlKSB7XHJcbiAgICAgICAgdmFyIHRyYW5zZmVyU3RhdGUgPSBuZXcgVHJhbnNmZXJTdGF0ZV8xKCk7XHJcbiAgICAgICAgdHJhbnNmZXJTdGF0ZS5zdG9yZSA9IGluaXRTdGF0ZTtcclxuICAgICAgICByZXR1cm4gdHJhbnNmZXJTdGF0ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgdmFsdWUgY29ycmVzcG9uZGluZyB0byBhIGtleS4gUmV0dXJuIGBkZWZhdWx0VmFsdWVgIGlmIGtleSBpcyBub3QgZm91bmQuXHJcbiAgICAgKi9cclxuICAgIFRyYW5zZmVyU3RhdGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXksIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlW2tleV0gIT09IHVuZGVmaW5lZCA/IHRoaXMuc3RvcmVba2V5XSA6IGRlZmF1bHRWYWx1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgdmFsdWUgY29ycmVzcG9uZGluZyB0byBhIGtleS5cclxuICAgICAqL1xyXG4gICAgVHJhbnNmZXJTdGF0ZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHsgdGhpcy5zdG9yZVtrZXldID0gdmFsdWU7IH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhIGtleSBmcm9tIHRoZSBzdG9yZS5cclxuICAgICAqL1xyXG4gICAgVHJhbnNmZXJTdGF0ZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSkgeyBkZWxldGUgdGhpcy5zdG9yZVtrZXldOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IHdoZXRoZXIgYSBrZXkgZXhpc3RzIGluIHRoZSBzdG9yZS5cclxuICAgICAqL1xyXG4gICAgVHJhbnNmZXJTdGF0ZS5wcm90b3R5cGUuaGFzS2V5ID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gdGhpcy5zdG9yZS5oYXNPd25Qcm9wZXJ0eShrZXkpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIHByb3ZpZGUgdGhlIHZhbHVlIGZvciBhIGtleSB3aGVuIGB0b0pzb25gIGlzIGNhbGxlZC5cclxuICAgICAqL1xyXG4gICAgVHJhbnNmZXJTdGF0ZS5wcm90b3R5cGUub25TZXJpYWxpemUgPSBmdW5jdGlvbiAoa2V5LCBjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMub25TZXJpYWxpemVDYWxsYmFja3Nba2V5XSA9IGNhbGxiYWNrO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2VyaWFsaXplIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzdG9yZSB0byBKU09OLlxyXG4gICAgICovXHJcbiAgICBUcmFuc2ZlclN0YXRlLnByb3RvdHlwZS50b0pzb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gQ2FsbCB0aGUgb25TZXJpYWxpemUgY2FsbGJhY2tzIGFuZCBwdXQgdGhvc2UgdmFsdWVzIGludG8gdGhlIHN0b3JlLlxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLm9uU2VyaWFsaXplQ2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9uU2VyaWFsaXplQ2FsbGJhY2tzLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yZVtrZXldID0gdGhpcy5vblNlcmlhbGl6ZUNhbGxiYWNrc1trZXldKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRXhjZXB0aW9uIGluIG9uU2VyaWFsaXplIGNhbGxiYWNrOiAnLCBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5zdG9yZSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIFRyYW5zZmVyU3RhdGVfMTtcclxuICAgIFRyYW5zZmVyU3RhdGUgPSBUcmFuc2ZlclN0YXRlXzEgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEluamVjdGFibGUoKVxyXG4gICAgXSwgVHJhbnNmZXJTdGF0ZSk7XHJcbiAgICByZXR1cm4gVHJhbnNmZXJTdGF0ZTtcclxufSgpKTtcclxuZXhwb3J0IHsgVHJhbnNmZXJTdGF0ZSB9O1xyXG5leHBvcnQgZnVuY3Rpb24gaW5pdFRyYW5zZmVyU3RhdGUoZG9jLCBhcHBJZCkge1xyXG4gICAgLy8gTG9jYXRlIHRoZSBzY3JpcHQgdGFnIHdpdGggdGhlIEpTT04gZGF0YSB0cmFuc2ZlcnJlZCBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAvLyBUaGUgaWQgb2YgdGhlIHNjcmlwdCB0YWcgaXMgc2V0IHRvIHRoZSBBbmd1bGFyIGFwcElkICsgJ3N0YXRlJy5cclxuICAgIHZhciBzY3JpcHQgPSBkb2MuZ2V0RWxlbWVudEJ5SWQoYXBwSWQgKyAnLXN0YXRlJyk7XHJcbiAgICB2YXIgaW5pdGlhbFN0YXRlID0ge307XHJcbiAgICBpZiAoc2NyaXB0ICYmIHNjcmlwdC50ZXh0Q29udGVudCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGluaXRpYWxTdGF0ZSA9IEpTT04ucGFyc2UodW5lc2NhcGVIdG1sKHNjcmlwdC50ZXh0Q29udGVudCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0V4Y2VwdGlvbiB3aGlsZSByZXN0b3JpbmcgVHJhbnNmZXJTdGF0ZSBmb3IgYXBwICcgKyBhcHBJZCwgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFRyYW5zZmVyU3RhdGUuaW5pdChpbml0aWFsU3RhdGUpO1xyXG59XHJcbi8qKlxyXG4gKiBOZ01vZHVsZSB0byBpbnN0YWxsIG9uIHRoZSBjbGllbnQgc2lkZSB3aGlsZSB1c2luZyB0aGUgYFRyYW5zZmVyU3RhdGVgIHRvIHRyYW5zZmVyIHN0YXRlIGZyb21cclxuICogc2VydmVyIHRvIGNsaWVudC5cclxuICpcclxuICogQHB1YmxpY0FwaVxyXG4gKi9cclxudmFyIEJyb3dzZXJUcmFuc2ZlclN0YXRlTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQnJvd3NlclRyYW5zZmVyU3RhdGVNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBCcm93c2VyVHJhbnNmZXJTdGF0ZU1vZHVsZSA9IHRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICAgICAgTmdNb2R1bGUoe1xyXG4gICAgICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IFRyYW5zZmVyU3RhdGUsIHVzZUZhY3Rvcnk6IGluaXRUcmFuc2ZlclN0YXRlLCBkZXBzOiBbRE9DVU1FTlQsIEFQUF9JRF0gfV0sXHJcbiAgICAgICAgfSlcclxuICAgIF0sIEJyb3dzZXJUcmFuc2ZlclN0YXRlTW9kdWxlKTtcclxuICAgIHJldHVybiBCcm93c2VyVHJhbnNmZXJTdGF0ZU1vZHVsZTtcclxufSgpKTtcclxuZXhwb3J0IHsgQnJvd3NlclRyYW5zZmVyU3RhdGVNb2R1bGUgfTtcciJdfQ==