/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { stringify } from '../util/stringify';
import { resolveForwardRef } from './forward_ref';
import { INJECTOR, NG_TEMP_TOKEN_PATH, NullInjector, THROW_IF_NOT_FOUND, USE_VALUE, catchInjectorError, formatError, ɵɵinject } from './injector_compatibility';
import { ɵɵdefineInjectable } from './interface/defs';
import { InjectFlags } from './interface/injector';
import { Inject, Optional, Self, SkipSelf } from './metadata';
import { createInjector } from './r3_injector';
/**
 * @param {?} providers
 * @param {?} parent
 * @param {?} name
 * @return {?}
 */
export function INJECTOR_IMPL__PRE_R3__(providers, parent, name) {
    return new StaticInjector(providers, parent, name);
}
/**
 * @param {?} providers
 * @param {?} parent
 * @param {?} name
 * @return {?}
 */
export function INJECTOR_IMPL__POST_R3__(providers, parent, name) {
    return createInjector({ name: name }, parent, providers, name);
}
/** @type {?} */
export const INJECTOR_IMPL = INJECTOR_IMPL__POST_R3__;
/**
 * Concrete injectors implement this interface.
 *
 * For more details, see the ["Dependency Injection Guide"](guide/dependency-injection).
 *
 * \@usageNotes
 * ### Example
 *
 * {\@example core/di/ts/injector_spec.ts region='Injector'}
 *
 * `Injector` returns itself when given `Injector` as a token:
 *
 * {\@example core/di/ts/injector_spec.ts region='injectInjector'}
 *
 * \@publicApi
 * @abstract
 */
export class Injector {
    /**
     * Create a new Injector which is configure using `StaticProvider`s.
     *
     * \@usageNotes
     * ### Example
     *
     * {\@example core/di/ts/provider_spec.ts region='ConstructorProvider'}
     * @param {?} options
     * @param {?=} parent
     * @return {?}
     */
    static create(options, parent) {
        if (Array.isArray(options)) {
            return INJECTOR_IMPL(options, parent, '');
        }
        else {
            return INJECTOR_IMPL(options.providers, options.parent, options.name || '');
        }
    }
}
Injector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
Injector.NULL = new NullInjector();
/** @nocollapse */
/** @nocollapse */ Injector.ngInjectableDef = ɵɵdefineInjectable({
    token: Injector,
    providedIn: (/** @type {?} */ ('any')),
    factory: (/**
     * @return {?}
     */
    () => ɵɵinject(INJECTOR)),
});
/**
 * \@internal
 * @nocollapse
 */
Injector.__NG_ELEMENT_ID__ = -1;
if (false) {
    /** @type {?} */
    Injector.THROW_IF_NOT_FOUND;
    /** @type {?} */
    Injector.NULL;
    /**
     * @nocollapse
     * @type {?}
     */
    Injector.ngInjectableDef;
    /**
     * \@internal
     * @nocollapse
     * @type {?}
     */
    Injector.__NG_ELEMENT_ID__;
    /**
     * Retrieves an instance from the injector based on the provided token.
     * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.
     * @abstract
     * @template T
     * @param {?} token
     * @param {?=} notFoundValue
     * @param {?=} flags
     * @return {?} The instance from the injector if defined, otherwise the `notFoundValue`.
     */
    Injector.prototype.get = function (token, notFoundValue, flags) { };
    /**
     * @deprecated from v4.0.0 use Type<T> or InjectionToken<T>
     * @suppress {duplicate}
     * @abstract
     * @param {?} token
     * @param {?=} notFoundValue
     * @return {?}
     */
    Injector.prototype.get = function (token, notFoundValue) { };
}
/** @type {?} */
const IDENT = (/**
 * @template T
 * @param {?} value
 * @return {?}
 */
function (value) {
    return value;
});
const ɵ0 = IDENT;
/** @type {?} */
const EMPTY = (/** @type {?} */ ([]));
/** @type {?} */
const CIRCULAR = IDENT;
/** @type {?} */
const MULTI_PROVIDER_FN = (/**
 * @return {?}
 */
function () {
    return Array.prototype.slice.call(arguments);
});
const ɵ1 = MULTI_PROVIDER_FN;
/** @enum {number} */
const OptionFlags = {
    Optional: 1,
    CheckSelf: 2,
    CheckParent: 4,
    Default: 6,
};
/** @type {?} */
const NO_NEW_LINE = 'ɵ';
export class StaticInjector {
    /**
     * @param {?} providers
     * @param {?=} parent
     * @param {?=} source
     */
    constructor(providers, parent = Injector.NULL, source = null) {
        this.parent = parent;
        this.source = source;
        /** @type {?} */
        const records = this._records = new Map();
        records.set(Injector, (/** @type {?} */ ({ token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false })));
        records.set(INJECTOR, (/** @type {?} */ ({ token: INJECTOR, fn: IDENT, deps: EMPTY, value: this, useNew: false })));
        recursivelyProcessProviders(records, providers);
    }
    /**
     * @param {?} token
     * @param {?=} notFoundValue
     * @param {?=} flags
     * @return {?}
     */
    get(token, notFoundValue, flags = InjectFlags.Default) {
        /** @type {?} */
        const record = this._records.get(token);
        try {
            return tryResolveToken(token, record, this._records, this.parent, notFoundValue, flags);
        }
        catch (e) {
            return catchInjectorError(e, token, 'StaticInjectorError', this.source);
        }
    }
    /**
     * @return {?}
     */
    toString() {
        /** @type {?} */
        const tokens = (/** @type {?} */ ([]));
        /** @type {?} */
        const records = this._records;
        records.forEach((/**
         * @param {?} v
         * @param {?} token
         * @return {?}
         */
        (v, token) => tokens.push(stringify(token))));
        return `StaticInjector[${tokens.join(', ')}]`;
    }
}
if (false) {
    /** @type {?} */
    StaticInjector.prototype.parent;
    /** @type {?} */
    StaticInjector.prototype.source;
    /**
     * @type {?}
     * @private
     */
    StaticInjector.prototype._records;
}
/**
 * @record
 */
function Record() { }
if (false) {
    /** @type {?} */
    Record.prototype.fn;
    /** @type {?} */
    Record.prototype.useNew;
    /** @type {?} */
    Record.prototype.deps;
    /** @type {?} */
    Record.prototype.value;
}
/**
 * @record
 */
function DependencyRecord() { }
if (false) {
    /** @type {?} */
    DependencyRecord.prototype.token;
    /** @type {?} */
    DependencyRecord.prototype.options;
}
/**
 * @param {?} provider
 * @return {?}
 */
function resolveProvider(provider) {
    /** @type {?} */
    const deps = computeDeps(provider);
    /** @type {?} */
    let fn = IDENT;
    /** @type {?} */
    let value = EMPTY;
    /** @type {?} */
    let useNew = false;
    /** @type {?} */
    let provide = resolveForwardRef(provider.provide);
    if (USE_VALUE in provider) {
        // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.
        value = ((/** @type {?} */ (provider))).useValue;
    }
    else if (((/** @type {?} */ (provider))).useFactory) {
        fn = ((/** @type {?} */ (provider))).useFactory;
    }
    else if (((/** @type {?} */ (provider))).useExisting) {
        // Just use IDENT
    }
    else if (((/** @type {?} */ (provider))).useClass) {
        useNew = true;
        fn = resolveForwardRef(((/** @type {?} */ (provider))).useClass);
    }
    else if (typeof provide == 'function') {
        useNew = true;
        fn = provide;
    }
    else {
        throw staticError('StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable', provider);
    }
    return { deps, fn, useNew, value };
}
/**
 * @param {?} token
 * @return {?}
 */
function multiProviderMixError(token) {
    return staticError('Cannot mix multi providers and regular providers', token);
}
/**
 * @param {?} records
 * @param {?} provider
 * @return {?}
 */
function recursivelyProcessProviders(records, provider) {
    if (provider) {
        provider = resolveForwardRef(provider);
        if (provider instanceof Array) {
            // if we have an array recurse into the array
            for (let i = 0; i < provider.length; i++) {
                recursivelyProcessProviders(records, provider[i]);
            }
        }
        else if (typeof provider === 'function') {
            // Functions were supported in ReflectiveInjector, but are not here. For safety give useful
            // error messages
            throw staticError('Function/Class not supported', provider);
        }
        else if (provider && typeof provider === 'object' && provider.provide) {
            // At this point we have what looks like a provider: {provide: ?, ....}
            /** @type {?} */
            let token = resolveForwardRef(provider.provide);
            /** @type {?} */
            const resolvedProvider = resolveProvider(provider);
            if (provider.multi === true) {
                // This is a multi provider.
                /** @type {?} */
                let multiProvider = records.get(token);
                if (multiProvider) {
                    if (multiProvider.fn !== MULTI_PROVIDER_FN) {
                        throw multiProviderMixError(token);
                    }
                }
                else {
                    // Create a placeholder factory which will look up the constituents of the multi provider.
                    records.set(token, multiProvider = (/** @type {?} */ ({
                        token: provider.provide,
                        deps: [],
                        useNew: false,
                        fn: MULTI_PROVIDER_FN,
                        value: EMPTY
                    })));
                }
                // Treat the provider as the token.
                token = provider;
                multiProvider.deps.push({ token, options: 6 /* Default */ });
            }
            /** @type {?} */
            const record = records.get(token);
            if (record && record.fn == MULTI_PROVIDER_FN) {
                throw multiProviderMixError(token);
            }
            records.set(token, resolvedProvider);
        }
        else {
            throw staticError('Unexpected provider', provider);
        }
    }
}
/**
 * @param {?} token
 * @param {?} record
 * @param {?} records
 * @param {?} parent
 * @param {?} notFoundValue
 * @param {?} flags
 * @return {?}
 */
function tryResolveToken(token, record, records, parent, notFoundValue, flags) {
    try {
        return resolveToken(token, record, records, parent, notFoundValue, flags);
    }
    catch (e) {
        // ensure that 'e' is of type Error.
        if (!(e instanceof Error)) {
            e = new Error(e);
        }
        /** @type {?} */
        const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];
        path.unshift(token);
        if (record && record.value == CIRCULAR) {
            // Reset the Circular flag.
            record.value = EMPTY;
        }
        throw e;
    }
}
/**
 * @param {?} token
 * @param {?} record
 * @param {?} records
 * @param {?} parent
 * @param {?} notFoundValue
 * @param {?} flags
 * @return {?}
 */
function resolveToken(token, record, records, parent, notFoundValue, flags) {
    /** @type {?} */
    let value;
    if (record && !(flags & InjectFlags.SkipSelf)) {
        // If we don't have a record, this implies that we don't own the provider hence don't know how
        // to resolve it.
        value = record.value;
        if (value == CIRCULAR) {
            throw Error(NO_NEW_LINE + 'Circular dependency');
        }
        else if (value === EMPTY) {
            record.value = CIRCULAR;
            /** @type {?} */
            let obj = undefined;
            /** @type {?} */
            let useNew = record.useNew;
            /** @type {?} */
            let fn = record.fn;
            /** @type {?} */
            let depRecords = record.deps;
            /** @type {?} */
            let deps = EMPTY;
            if (depRecords.length) {
                deps = [];
                for (let i = 0; i < depRecords.length; i++) {
                    /** @type {?} */
                    const depRecord = depRecords[i];
                    /** @type {?} */
                    const options = depRecord.options;
                    /** @type {?} */
                    const childRecord = options & 2 /* CheckSelf */ ? records.get(depRecord.token) : undefined;
                    deps.push(tryResolveToken(
                    // Current Token to resolve
                    depRecord.token, 
                    // A record which describes how to resolve the token.
                    // If undefined, this means we don't have such a record
                    childRecord, 
                    // Other records we know about.
                    records, 
                    // If we don't know how to resolve dependency and we should not check parent for it,
                    // than pass in Null injector.
                    !childRecord && !(options & 4 /* CheckParent */) ? Injector.NULL : parent, options & 1 /* Optional */ ? null : Injector.THROW_IF_NOT_FOUND, InjectFlags.Default));
                }
            }
            record.value = value = useNew ? new ((/** @type {?} */ (fn)))(...deps) : fn.apply(obj, deps);
        }
    }
    else if (!(flags & InjectFlags.Self)) {
        value = parent.get(token, notFoundValue, InjectFlags.Default);
    }
    return value;
}
/**
 * @param {?} provider
 * @return {?}
 */
function computeDeps(provider) {
    /** @type {?} */
    let deps = EMPTY;
    /** @type {?} */
    const providerDeps = ((/** @type {?} */ (provider))).deps;
    if (providerDeps && providerDeps.length) {
        deps = [];
        for (let i = 0; i < providerDeps.length; i++) {
            /** @type {?} */
            let options = 6 /* Default */;
            /** @type {?} */
            let token = resolveForwardRef(providerDeps[i]);
            if (token instanceof Array) {
                for (let j = 0, annotations = token; j < annotations.length; j++) {
                    /** @type {?} */
                    const annotation = annotations[j];
                    if (annotation instanceof Optional || annotation == Optional) {
                        options = options | 1 /* Optional */;
                    }
                    else if (annotation instanceof SkipSelf || annotation == SkipSelf) {
                        options = options & ~2 /* CheckSelf */;
                    }
                    else if (annotation instanceof Self || annotation == Self) {
                        options = options & ~4 /* CheckParent */;
                    }
                    else if (annotation instanceof Inject) {
                        token = ((/** @type {?} */ (annotation))).token;
                    }
                    else {
                        token = resolveForwardRef(annotation);
                    }
                }
            }
            deps.push({ token, options });
        }
    }
    else if (((/** @type {?} */ (provider))).useExisting) {
        /** @type {?} */
        const token = resolveForwardRef(((/** @type {?} */ (provider))).useExisting);
        deps = [{ token, options: 6 /* Default */ }];
    }
    else if (!providerDeps && !(USE_VALUE in provider)) {
        // useValue & useExisting are the only ones which are exempt from deps all others need it.
        throw staticError('\'deps\' required', provider);
    }
    return deps;
}
/**
 * @param {?} text
 * @param {?} obj
 * @return {?}
 */
function staticError(text, obj) {
    return new Error(formatError(text, obj, 'StaticInjectorError'));
}
export { ɵ0, ɵ1 };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L1Byb2plY3RzL1Rlc3RQcm9qZWN0L0NoYXJnaW5nL0NoYXJnaW5nL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL2VzbTIwMTUvc3JjL2RpL2luamVjdG9yLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZCQXFDNkIsd0JBQXVCIiwiZmlsZSI6ImluamVjdG9yLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxyXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsY29uc3RhbnRQcm9wZXJ0eSxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXHJcbiAqL1xyXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXHJcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gJy4uL3V0aWwvc3RyaW5naWZ5JztcclxuaW1wb3J0IHsgcmVzb2x2ZUZvcndhcmRSZWYgfSBmcm9tICcuL2ZvcndhcmRfcmVmJztcclxuaW1wb3J0IHsgSU5KRUNUT1IsIE5HX1RFTVBfVE9LRU5fUEFUSCwgTnVsbEluamVjdG9yLCBUSFJPV19JRl9OT1RfRk9VTkQsIFVTRV9WQUxVRSwgY2F0Y2hJbmplY3RvckVycm9yLCBmb3JtYXRFcnJvciwgybXJtWluamVjdCB9IGZyb20gJy4vaW5qZWN0b3JfY29tcGF0aWJpbGl0eSc7XHJcbmltcG9ydCB7IMm1ybVkZWZpbmVJbmplY3RhYmxlIH0gZnJvbSAnLi9pbnRlcmZhY2UvZGVmcyc7XHJcbmltcG9ydCB7IEluamVjdEZsYWdzIH0gZnJvbSAnLi9pbnRlcmZhY2UvaW5qZWN0b3InO1xyXG5pbXBvcnQgeyBJbmplY3QsIE9wdGlvbmFsLCBTZWxmLCBTa2lwU2VsZiB9IGZyb20gJy4vbWV0YWRhdGEnO1xyXG5pbXBvcnQgeyBjcmVhdGVJbmplY3RvciB9IGZyb20gJy4vcjNfaW5qZWN0b3InO1xyXG4vKipcclxuICogQHBhcmFtIHs/fSBwcm92aWRlcnNcclxuICogQHBhcmFtIHs/fSBwYXJlbnRcclxuICogQHBhcmFtIHs/fSBuYW1lXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gSU5KRUNUT1JfSU1QTF9fUFJFX1IzX18ocHJvdmlkZXJzLCBwYXJlbnQsIG5hbWUpIHtcclxuICAgIHJldHVybiBuZXcgU3RhdGljSW5qZWN0b3IocHJvdmlkZXJzLCBwYXJlbnQsIG5hbWUpO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IHByb3ZpZGVyc1xyXG4gKiBAcGFyYW0gez99IHBhcmVudFxyXG4gKiBAcGFyYW0gez99IG5hbWVcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBJTkpFQ1RPUl9JTVBMX19QT1NUX1IzX18ocHJvdmlkZXJzLCBwYXJlbnQsIG5hbWUpIHtcclxuICAgIHJldHVybiBjcmVhdGVJbmplY3Rvcih7IG5hbWU6IG5hbWUgfSwgcGFyZW50LCBwcm92aWRlcnMsIG5hbWUpO1xyXG59XHJcbi8qKiBAdHlwZSB7P30gKi9cclxuZXhwb3J0IGNvbnN0IElOSkVDVE9SX0lNUEwgPSBJTkpFQ1RPUl9JTVBMX19QUkVfUjNfXztcclxuLyoqXHJcbiAqIENvbmNyZXRlIGluamVjdG9ycyBpbXBsZW1lbnQgdGhpcyBpbnRlcmZhY2UuXHJcbiAqXHJcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB0aGUgW1wiRGVwZW5kZW5jeSBJbmplY3Rpb24gR3VpZGVcIl0oZ3VpZGUvZGVwZW5kZW5jeS1pbmplY3Rpb24pLlxyXG4gKlxyXG4gKiBcXEB1c2FnZU5vdGVzXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIHtcXEBleGFtcGxlIGNvcmUvZGkvdHMvaW5qZWN0b3Jfc3BlYy50cyByZWdpb249J0luamVjdG9yJ31cclxuICpcclxuICogYEluamVjdG9yYCByZXR1cm5zIGl0c2VsZiB3aGVuIGdpdmVuIGBJbmplY3RvcmAgYXMgYSB0b2tlbjpcclxuICpcclxuICoge1xcQGV4YW1wbGUgY29yZS9kaS90cy9pbmplY3Rvcl9zcGVjLnRzIHJlZ2lvbj0naW5qZWN0SW5qZWN0b3InfVxyXG4gKlxyXG4gKiBcXEBwdWJsaWNBcGlcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSW5qZWN0b3Ige1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgSW5qZWN0b3Igd2hpY2ggaXMgY29uZmlndXJlIHVzaW5nIGBTdGF0aWNQcm92aWRlcmBzLlxyXG4gICAgICpcclxuICAgICAqIFxcQHVzYWdlTm90ZXNcclxuICAgICAqICMjIyBFeGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICoge1xcQGV4YW1wbGUgY29yZS9kaS90cy9wcm92aWRlcl9zcGVjLnRzIHJlZ2lvbj0nQ29uc3RydWN0b3JQcm92aWRlcid9XHJcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbnNcclxuICAgICAqIEBwYXJhbSB7Pz19IHBhcmVudFxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZShvcHRpb25zLCBwYXJlbnQpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gSU5KRUNUT1JfSU1QTChvcHRpb25zLCBwYXJlbnQsICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBJTkpFQ1RPUl9JTVBMKG9wdGlvbnMucHJvdmlkZXJzLCBvcHRpb25zLnBhcmVudCwgb3B0aW9ucy5uYW1lIHx8ICcnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuSW5qZWN0b3IuVEhST1dfSUZfTk9UX0ZPVU5EID0gVEhST1dfSUZfTk9UX0ZPVU5EO1xyXG5JbmplY3Rvci5OVUxMID0gbmV3IE51bGxJbmplY3RvcigpO1xyXG4vKiogQG5vY29sbGFwc2UgKi9cclxuLyoqIEBub2NvbGxhcHNlICovIEluamVjdG9yLm5nSW5qZWN0YWJsZURlZiA9IMm1ybVkZWZpbmVJbmplY3RhYmxlKHtcclxuICAgIHRva2VuOiBJbmplY3RvcixcclxuICAgIHByb3ZpZGVkSW46ICgvKiogQHR5cGUgez99ICovICgnYW55JykpLFxyXG4gICAgZmFjdG9yeTogKC8qKlxyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgKCkgPT4gybXJtWluamVjdChJTkpFQ1RPUikpLFxyXG59KTtcclxuLyoqXHJcbiAqIFxcQGludGVybmFsXHJcbiAqIEBub2NvbGxhcHNlXHJcbiAqL1xyXG5JbmplY3Rvci5fX05HX0VMRU1FTlRfSURfXyA9IC0xO1xyXG5pZiAoZmFsc2UpIHtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIEluamVjdG9yLlRIUk9XX0lGX05PVF9GT1VORDtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIEluamVjdG9yLk5VTEw7XHJcbiAgICAvKipcclxuICAgICAqIEBub2NvbGxhcHNlXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqL1xyXG4gICAgSW5qZWN0b3IubmdJbmplY3RhYmxlRGVmO1xyXG4gICAgLyoqXHJcbiAgICAgKiBcXEBpbnRlcm5hbFxyXG4gICAgICogQG5vY29sbGFwc2VcclxuICAgICAqIEB0eXBlIHs/fVxyXG4gICAgICovXHJcbiAgICBJbmplY3Rvci5fX05HX0VMRU1FTlRfSURfXztcclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIGFuIGluc3RhbmNlIGZyb20gdGhlIGluamVjdG9yIGJhc2VkIG9uIHRoZSBwcm92aWRlZCB0b2tlbi5cclxuICAgICAqIEB0aHJvd3MgV2hlbiB0aGUgYG5vdEZvdW5kVmFsdWVgIGlzIGB1bmRlZmluZWRgIG9yIGBJbmplY3Rvci5USFJPV19JRl9OT1RfRk9VTkRgLlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAdGVtcGxhdGUgVFxyXG4gICAgICogQHBhcmFtIHs/fSB0b2tlblxyXG4gICAgICogQHBhcmFtIHs/PX0gbm90Rm91bmRWYWx1ZVxyXG4gICAgICogQHBhcmFtIHs/PX0gZmxhZ3NcclxuICAgICAqIEByZXR1cm4gez99IFRoZSBpbnN0YW5jZSBmcm9tIHRoZSBpbmplY3RvciBpZiBkZWZpbmVkLCBvdGhlcndpc2UgdGhlIGBub3RGb3VuZFZhbHVlYC5cclxuICAgICAqL1xyXG4gICAgSW5qZWN0b3IucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbiwgbm90Rm91bmRWYWx1ZSwgZmxhZ3MpIHsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgZnJvbSB2NC4wLjAgdXNlIFR5cGU8VD4gb3IgSW5qZWN0aW9uVG9rZW48VD5cclxuICAgICAqIEBzdXBwcmVzcyB7ZHVwbGljYXRlfVxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gez99IHRva2VuXHJcbiAgICAgKiBAcGFyYW0gez89fSBub3RGb3VuZFZhbHVlXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICBJbmplY3Rvci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRva2VuLCBub3RGb3VuZFZhbHVlKSB7IH07XHJcbn1cclxuLyoqIEB0eXBlIHs/fSAqL1xyXG5jb25zdCBJREVOVCA9ICgvKipcclxuICogQHRlbXBsYXRlIFRcclxuICogQHBhcmFtIHs/fSB2YWx1ZVxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn0pO1xyXG5jb25zdCDJtTAgPSBJREVOVDtcclxuLyoqIEB0eXBlIHs/fSAqL1xyXG5jb25zdCBFTVBUWSA9ICgvKiogQHR5cGUgez99ICovIChbXSkpO1xyXG4vKiogQHR5cGUgez99ICovXHJcbmNvbnN0IENJUkNVTEFSID0gSURFTlQ7XHJcbi8qKiBAdHlwZSB7P30gKi9cclxuY29uc3QgTVVMVElfUFJPVklERVJfRk4gPSAoLyoqXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxufSk7XHJcbmNvbnN0IMm1MSA9IE1VTFRJX1BST1ZJREVSX0ZOO1xyXG4vKiogQGVudW0ge251bWJlcn0gKi9cclxuY29uc3QgT3B0aW9uRmxhZ3MgPSB7XHJcbiAgICBPcHRpb25hbDogMSxcclxuICAgIENoZWNrU2VsZjogMixcclxuICAgIENoZWNrUGFyZW50OiA0LFxyXG4gICAgRGVmYXVsdDogNixcclxufTtcclxuLyoqIEB0eXBlIHs/fSAqL1xyXG5jb25zdCBOT19ORVdfTElORSA9ICfJtSc7XHJcbmV4cG9ydCBjbGFzcyBTdGF0aWNJbmplY3RvciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJzXHJcbiAgICAgKiBAcGFyYW0gez89fSBwYXJlbnRcclxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcnMsIHBhcmVudCA9IEluamVjdG9yLk5VTEwsIHNvdXJjZSA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgY29uc3QgcmVjb3JkcyA9IHRoaXMuX3JlY29yZHMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgcmVjb3Jkcy5zZXQoSW5qZWN0b3IsICgvKiogQHR5cGUgez99ICovICh7IHRva2VuOiBJbmplY3RvciwgZm46IElERU5ULCBkZXBzOiBFTVBUWSwgdmFsdWU6IHRoaXMsIHVzZU5ldzogZmFsc2UgfSkpKTtcclxuICAgICAgICByZWNvcmRzLnNldChJTkpFQ1RPUiwgKC8qKiBAdHlwZSB7P30gKi8gKHsgdG9rZW46IElOSkVDVE9SLCBmbjogSURFTlQsIGRlcHM6IEVNUFRZLCB2YWx1ZTogdGhpcywgdXNlTmV3OiBmYWxzZSB9KSkpO1xyXG4gICAgICAgIHJlY3Vyc2l2ZWx5UHJvY2Vzc1Byb3ZpZGVycyhyZWNvcmRzLCBwcm92aWRlcnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez99IHRva2VuXHJcbiAgICAgKiBAcGFyYW0gez89fSBub3RGb3VuZFZhbHVlXHJcbiAgICAgKiBAcGFyYW0gez89fSBmbGFnc1xyXG4gICAgICogQHJldHVybiB7P31cclxuICAgICAqL1xyXG4gICAgZ2V0KHRva2VuLCBub3RGb3VuZFZhbHVlLCBmbGFncyA9IEluamVjdEZsYWdzLkRlZmF1bHQpIHtcclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgY29uc3QgcmVjb3JkID0gdGhpcy5fcmVjb3Jkcy5nZXQodG9rZW4pO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnlSZXNvbHZlVG9rZW4odG9rZW4sIHJlY29yZCwgdGhpcy5fcmVjb3JkcywgdGhpcy5wYXJlbnQsIG5vdEZvdW5kVmFsdWUsIGZsYWdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhdGNoSW5qZWN0b3JFcnJvcihlLCB0b2tlbiwgJ1N0YXRpY0luamVjdG9yRXJyb3InLCB0aGlzLnNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHs/fVxyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgY29uc3QgdG9rZW5zID0gKC8qKiBAdHlwZSB7P30gKi8gKFtdKSk7XHJcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgIGNvbnN0IHJlY29yZHMgPSB0aGlzLl9yZWNvcmRzO1xyXG4gICAgICAgIHJlY29yZHMuZm9yRWFjaCgoLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHs/fSB2XHJcbiAgICAgICAgICogQHBhcmFtIHs/fSB0b2tlblxyXG4gICAgICAgICAqIEByZXR1cm4gez99XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgKHYsIHRva2VuKSA9PiB0b2tlbnMucHVzaChzdHJpbmdpZnkodG9rZW4pKSkpO1xyXG4gICAgICAgIHJldHVybiBgU3RhdGljSW5qZWN0b3JbJHt0b2tlbnMuam9pbignLCAnKX1dYDtcclxuICAgIH1cclxufVxyXG5pZiAoZmFsc2UpIHtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIFN0YXRpY0luamVjdG9yLnByb3RvdHlwZS5wYXJlbnQ7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBTdGF0aWNJbmplY3Rvci5wcm90b3R5cGUuc291cmNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7P31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIFN0YXRpY0luamVjdG9yLnByb3RvdHlwZS5fcmVjb3JkcztcclxufVxyXG4vKipcclxuICogQHJlY29yZFxyXG4gKi9cclxuZnVuY3Rpb24gUmVjb3JkKCkgeyB9XHJcbmlmIChmYWxzZSkge1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgUmVjb3JkLnByb3RvdHlwZS5mbjtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIFJlY29yZC5wcm90b3R5cGUudXNlTmV3O1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgUmVjb3JkLnByb3RvdHlwZS5kZXBzO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgUmVjb3JkLnByb3RvdHlwZS52YWx1ZTtcclxufVxyXG4vKipcclxuICogQHJlY29yZFxyXG4gKi9cclxuZnVuY3Rpb24gRGVwZW5kZW5jeVJlY29yZCgpIHsgfVxyXG5pZiAoZmFsc2UpIHtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIERlcGVuZGVuY3lSZWNvcmQucHJvdG90eXBlLnRva2VuO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgRGVwZW5kZW5jeVJlY29yZC5wcm90b3R5cGUub3B0aW9ucztcclxufVxyXG4vKipcclxuICogQHBhcmFtIHs/fSBwcm92aWRlclxyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZVByb3ZpZGVyKHByb3ZpZGVyKSB7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBjb25zdCBkZXBzID0gY29tcHV0ZURlcHMocHJvdmlkZXIpO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgbGV0IGZuID0gSURFTlQ7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBsZXQgdmFsdWUgPSBFTVBUWTtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIGxldCB1c2VOZXcgPSBmYWxzZTtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIGxldCBwcm92aWRlID0gcmVzb2x2ZUZvcndhcmRSZWYocHJvdmlkZXIucHJvdmlkZSk7XHJcbiAgICBpZiAoVVNFX1ZBTFVFIGluIHByb3ZpZGVyKSB7XHJcbiAgICAgICAgLy8gV2UgbmVlZCB0byB1c2UgVVNFX1ZBTFVFIGluIHByb3ZpZGVyIHNpbmNlIHByb3ZpZGVyLnVzZVZhbHVlIGNvdWxkIGJlIGRlZmluZWQgYXMgdW5kZWZpbmVkLlxyXG4gICAgICAgIHZhbHVlID0gKCgvKiogQHR5cGUgez99ICovIChwcm92aWRlcikpKS51c2VWYWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgoLyoqIEB0eXBlIHs/fSAqLyAocHJvdmlkZXIpKSkudXNlRmFjdG9yeSkge1xyXG4gICAgICAgIGZuID0gKCgvKiogQHR5cGUgez99ICovIChwcm92aWRlcikpKS51c2VGYWN0b3J5O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKCgvKiogQHR5cGUgez99ICovIChwcm92aWRlcikpKS51c2VFeGlzdGluZykge1xyXG4gICAgICAgIC8vIEp1c3QgdXNlIElERU5UXHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgoKC8qKiBAdHlwZSB7P30gKi8gKHByb3ZpZGVyKSkpLnVzZUNsYXNzKSB7XHJcbiAgICAgICAgdXNlTmV3ID0gdHJ1ZTtcclxuICAgICAgICBmbiA9IHJlc29sdmVGb3J3YXJkUmVmKCgoLyoqIEB0eXBlIHs/fSAqLyAocHJvdmlkZXIpKSkudXNlQ2xhc3MpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHByb3ZpZGUgPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHVzZU5ldyA9IHRydWU7XHJcbiAgICAgICAgZm4gPSBwcm92aWRlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgc3RhdGljRXJyb3IoJ1N0YXRpY1Byb3ZpZGVyIGRvZXMgbm90IGhhdmUgW3VzZVZhbHVlfHVzZUZhY3Rvcnl8dXNlRXhpc3Rpbmd8dXNlQ2xhc3NdIG9yIFtwcm92aWRlXSBpcyBub3QgbmV3YWJsZScsIHByb3ZpZGVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGRlcHMsIGZuLCB1c2VOZXcsIHZhbHVlIH07XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gdG9rZW5cclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIG11bHRpUHJvdmlkZXJNaXhFcnJvcih0b2tlbikge1xyXG4gICAgcmV0dXJuIHN0YXRpY0Vycm9yKCdDYW5ub3QgbWl4IG11bHRpIHByb3ZpZGVycyBhbmQgcmVndWxhciBwcm92aWRlcnMnLCB0b2tlbik7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gcmVjb3Jkc1xyXG4gKiBAcGFyYW0gez99IHByb3ZpZGVyXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiByZWN1cnNpdmVseVByb2Nlc3NQcm92aWRlcnMocmVjb3JkcywgcHJvdmlkZXIpIHtcclxuICAgIGlmIChwcm92aWRlcikge1xyXG4gICAgICAgIHByb3ZpZGVyID0gcmVzb2x2ZUZvcndhcmRSZWYocHJvdmlkZXIpO1xyXG4gICAgICAgIGlmIChwcm92aWRlciBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYW4gYXJyYXkgcmVjdXJzZSBpbnRvIHRoZSBhcnJheVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3ZpZGVyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICByZWN1cnNpdmVseVByb2Nlc3NQcm92aWRlcnMocmVjb3JkcywgcHJvdmlkZXJbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwcm92aWRlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAvLyBGdW5jdGlvbnMgd2VyZSBzdXBwb3J0ZWQgaW4gUmVmbGVjdGl2ZUluamVjdG9yLCBidXQgYXJlIG5vdCBoZXJlLiBGb3Igc2FmZXR5IGdpdmUgdXNlZnVsXHJcbiAgICAgICAgICAgIC8vIGVycm9yIG1lc3NhZ2VzXHJcbiAgICAgICAgICAgIHRocm93IHN0YXRpY0Vycm9yKCdGdW5jdGlvbi9DbGFzcyBub3Qgc3VwcG9ydGVkJywgcHJvdmlkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwcm92aWRlciAmJiB0eXBlb2YgcHJvdmlkZXIgPT09ICdvYmplY3QnICYmIHByb3ZpZGVyLnByb3ZpZGUpIHtcclxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBoYXZlIHdoYXQgbG9va3MgbGlrZSBhIHByb3ZpZGVyOiB7cHJvdmlkZTogPywgLi4uLn1cclxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgICAgICBsZXQgdG9rZW4gPSByZXNvbHZlRm9yd2FyZFJlZihwcm92aWRlci5wcm92aWRlKTtcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZFByb3ZpZGVyID0gcmVzb2x2ZVByb3ZpZGVyKHByb3ZpZGVyKTtcclxuICAgICAgICAgICAgaWYgKHByb3ZpZGVyLm11bHRpID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgbXVsdGkgcHJvdmlkZXIuXHJcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgICAgICAgICBsZXQgbXVsdGlQcm92aWRlciA9IHJlY29yZHMuZ2V0KHRva2VuKTtcclxuICAgICAgICAgICAgICAgIGlmIChtdWx0aVByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpUHJvdmlkZXIuZm4gIT09IE1VTFRJX1BST1ZJREVSX0ZOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG11bHRpUHJvdmlkZXJNaXhFcnJvcih0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgcGxhY2Vob2xkZXIgZmFjdG9yeSB3aGljaCB3aWxsIGxvb2sgdXAgdGhlIGNvbnN0aXR1ZW50cyBvZiB0aGUgbXVsdGkgcHJvdmlkZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVjb3Jkcy5zZXQodG9rZW4sIG11bHRpUHJvdmlkZXIgPSAoLyoqIEB0eXBlIHs/fSAqLyAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogcHJvdmlkZXIucHJvdmlkZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZU5ldzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuOiBNVUxUSV9QUk9WSURFUl9GTixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IEVNUFRZXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFRyZWF0IHRoZSBwcm92aWRlciBhcyB0aGUgdG9rZW4uXHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHByb3ZpZGVyO1xyXG4gICAgICAgICAgICAgICAgbXVsdGlQcm92aWRlci5kZXBzLnB1c2goeyB0b2tlbiwgb3B0aW9uczogNiAvKiBEZWZhdWx0ICovIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgY29uc3QgcmVjb3JkID0gcmVjb3Jkcy5nZXQodG9rZW4pO1xyXG4gICAgICAgICAgICBpZiAocmVjb3JkICYmIHJlY29yZC5mbiA9PSBNVUxUSV9QUk9WSURFUl9GTikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbXVsdGlQcm92aWRlck1peEVycm9yKHRva2VuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZWNvcmRzLnNldCh0b2tlbiwgcmVzb2x2ZWRQcm92aWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBzdGF0aWNFcnJvcignVW5leHBlY3RlZCBwcm92aWRlcicsIHByb3ZpZGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gdG9rZW5cclxuICogQHBhcmFtIHs/fSByZWNvcmRcclxuICogQHBhcmFtIHs/fSByZWNvcmRzXHJcbiAqIEBwYXJhbSB7P30gcGFyZW50XHJcbiAqIEBwYXJhbSB7P30gbm90Rm91bmRWYWx1ZVxyXG4gKiBAcGFyYW0gez99IGZsYWdzXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiB0cnlSZXNvbHZlVG9rZW4odG9rZW4sIHJlY29yZCwgcmVjb3JkcywgcGFyZW50LCBub3RGb3VuZFZhbHVlLCBmbGFncykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gcmVzb2x2ZVRva2VuKHRva2VuLCByZWNvcmQsIHJlY29yZHMsIHBhcmVudCwgbm90Rm91bmRWYWx1ZSwgZmxhZ3MpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyBlbnN1cmUgdGhhdCAnZScgaXMgb2YgdHlwZSBFcnJvci5cclxuICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgRXJyb3IpKSB7XHJcbiAgICAgICAgICAgIGUgPSBuZXcgRXJyb3IoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICBjb25zdCBwYXRoID0gZVtOR19URU1QX1RPS0VOX1BBVEhdID0gZVtOR19URU1QX1RPS0VOX1BBVEhdIHx8IFtdO1xyXG4gICAgICAgIHBhdGgudW5zaGlmdCh0b2tlbik7XHJcbiAgICAgICAgaWYgKHJlY29yZCAmJiByZWNvcmQudmFsdWUgPT0gQ0lSQ1VMQVIpIHtcclxuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIENpcmN1bGFyIGZsYWcuXHJcbiAgICAgICAgICAgIHJlY29yZC52YWx1ZSA9IEVNUFRZO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gez99IHRva2VuXHJcbiAqIEBwYXJhbSB7P30gcmVjb3JkXHJcbiAqIEBwYXJhbSB7P30gcmVjb3Jkc1xyXG4gKiBAcGFyYW0gez99IHBhcmVudFxyXG4gKiBAcGFyYW0gez99IG5vdEZvdW5kVmFsdWVcclxuICogQHBhcmFtIHs/fSBmbGFnc1xyXG4gKiBAcmV0dXJuIHs/fVxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZVRva2VuKHRva2VuLCByZWNvcmQsIHJlY29yZHMsIHBhcmVudCwgbm90Rm91bmRWYWx1ZSwgZmxhZ3MpIHtcclxuICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgIGxldCB2YWx1ZTtcclxuICAgIGlmIChyZWNvcmQgJiYgIShmbGFncyAmIEluamVjdEZsYWdzLlNraXBTZWxmKSkge1xyXG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSByZWNvcmQsIHRoaXMgaW1wbGllcyB0aGF0IHdlIGRvbid0IG93biB0aGUgcHJvdmlkZXIgaGVuY2UgZG9uJ3Qga25vdyBob3dcclxuICAgICAgICAvLyB0byByZXNvbHZlIGl0LlxyXG4gICAgICAgIHZhbHVlID0gcmVjb3JkLnZhbHVlO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBDSVJDVUxBUikge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihOT19ORVdfTElORSArICdDaXJjdWxhciBkZXBlbmRlbmN5Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBFTVBUWSkge1xyXG4gICAgICAgICAgICByZWNvcmQudmFsdWUgPSBDSVJDVUxBUjtcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgICAgICBsZXQgb2JqID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgICAgIGxldCB1c2VOZXcgPSByZWNvcmQudXNlTmV3O1xyXG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgICAgIGxldCBmbiA9IHJlY29yZC5mbjtcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgICAgICBsZXQgZGVwUmVjb3JkcyA9IHJlY29yZC5kZXBzO1xyXG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgICAgIGxldCBkZXBzID0gRU1QVFk7XHJcbiAgICAgICAgICAgIGlmIChkZXBSZWNvcmRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZGVwcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBSZWNvcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlcFJlY29yZCA9IGRlcFJlY29yZHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBkZXBSZWNvcmQub3B0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRSZWNvcmQgPSBvcHRpb25zICYgMiAvKiBDaGVja1NlbGYgKi8gPyByZWNvcmRzLmdldChkZXBSZWNvcmQudG9rZW4pIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaCh0cnlSZXNvbHZlVG9rZW4oXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3VycmVudCBUb2tlbiB0byByZXNvbHZlXHJcbiAgICAgICAgICAgICAgICAgICAgZGVwUmVjb3JkLnRva2VuLCBcclxuICAgICAgICAgICAgICAgICAgICAvLyBBIHJlY29yZCB3aGljaCBkZXNjcmliZXMgaG93IHRvIHJlc29sdmUgdGhlIHRva2VuLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHVuZGVmaW5lZCwgdGhpcyBtZWFucyB3ZSBkb24ndCBoYXZlIHN1Y2ggYSByZWNvcmRcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZFJlY29yZCwgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXIgcmVjb3JkcyB3ZSBrbm93IGFib3V0LlxyXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZHMsIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGtub3cgaG93IHRvIHJlc29sdmUgZGVwZW5kZW5jeSBhbmQgd2Ugc2hvdWxkIG5vdCBjaGVjayBwYXJlbnQgZm9yIGl0LFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYW4gcGFzcyBpbiBOdWxsIGluamVjdG9yLlxyXG4gICAgICAgICAgICAgICAgICAgICFjaGlsZFJlY29yZCAmJiAhKG9wdGlvbnMgJiA0IC8qIENoZWNrUGFyZW50ICovKSA/IEluamVjdG9yLk5VTEwgOiBwYXJlbnQsIG9wdGlvbnMgJiAxIC8qIE9wdGlvbmFsICovID8gbnVsbCA6IEluamVjdG9yLlRIUk9XX0lGX05PVF9GT1VORCwgSW5qZWN0RmxhZ3MuRGVmYXVsdCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlY29yZC52YWx1ZSA9IHZhbHVlID0gdXNlTmV3ID8gbmV3ICgoLyoqIEB0eXBlIHs/fSAqLyAoZm4pKSkoLi4uZGVwcykgOiBmbi5hcHBseShvYmosIGRlcHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCEoZmxhZ3MgJiBJbmplY3RGbGFncy5TZWxmKSkge1xyXG4gICAgICAgIHZhbHVlID0gcGFyZW50LmdldCh0b2tlbiwgbm90Rm91bmRWYWx1ZSwgSW5qZWN0RmxhZ3MuRGVmYXVsdCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSB7P30gcHJvdmlkZXJcclxuICogQHJldHVybiB7P31cclxuICovXHJcbmZ1bmN0aW9uIGNvbXB1dGVEZXBzKHByb3ZpZGVyKSB7XHJcbiAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICBsZXQgZGVwcyA9IEVNUFRZO1xyXG4gICAgLyoqIEB0eXBlIHs/fSAqL1xyXG4gICAgY29uc3QgcHJvdmlkZXJEZXBzID0gKCgvKiogQHR5cGUgez99ICovIChwcm92aWRlcikpKS5kZXBzO1xyXG4gICAgaWYgKHByb3ZpZGVyRGVwcyAmJiBwcm92aWRlckRlcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgZGVwcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvdmlkZXJEZXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgbGV0IG9wdGlvbnMgPSA2IC8qIERlZmF1bHQgKi87XHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cclxuICAgICAgICAgICAgbGV0IHRva2VuID0gcmVzb2x2ZUZvcndhcmRSZWYocHJvdmlkZXJEZXBzW2ldKTtcclxuICAgICAgICAgICAgaWYgKHRva2VuIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBhbm5vdGF0aW9ucyA9IHRva2VuOyBqIDwgYW5ub3RhdGlvbnMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5ub3RhdGlvbiA9IGFubm90YXRpb25zW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uIGluc3RhbmNlb2YgT3B0aW9uYWwgfHwgYW5ub3RhdGlvbiA9PSBPcHRpb25hbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8IDEgLyogT3B0aW9uYWwgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFubm90YXRpb24gaW5zdGFuY2VvZiBTa2lwU2VsZiB8fCBhbm5vdGF0aW9uID09IFNraXBTZWxmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zICYgfjIgLyogQ2hlY2tTZWxmICovO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhbm5vdGF0aW9uIGluc3RhbmNlb2YgU2VsZiB8fCBhbm5vdGF0aW9uID09IFNlbGYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgJiB+NCAvKiBDaGVja1BhcmVudCAqLztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYW5ub3RhdGlvbiBpbnN0YW5jZW9mIEluamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9ICgoLyoqIEB0eXBlIHs/fSAqLyAoYW5ub3RhdGlvbikpKS50b2tlbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gcmVzb2x2ZUZvcndhcmRSZWYoYW5ub3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlcHMucHVzaCh7IHRva2VuLCBvcHRpb25zIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgoLyoqIEB0eXBlIHs/fSAqLyAocHJvdmlkZXIpKSkudXNlRXhpc3RpbmcpIHtcclxuICAgICAgICAvKiogQHR5cGUgez99ICovXHJcbiAgICAgICAgY29uc3QgdG9rZW4gPSByZXNvbHZlRm9yd2FyZFJlZigoKC8qKiBAdHlwZSB7P30gKi8gKHByb3ZpZGVyKSkpLnVzZUV4aXN0aW5nKTtcclxuICAgICAgICBkZXBzID0gW3sgdG9rZW4sIG9wdGlvbnM6IDYgLyogRGVmYXVsdCAqLyB9XTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFwcm92aWRlckRlcHMgJiYgIShVU0VfVkFMVUUgaW4gcHJvdmlkZXIpKSB7XHJcbiAgICAgICAgLy8gdXNlVmFsdWUgJiB1c2VFeGlzdGluZyBhcmUgdGhlIG9ubHkgb25lcyB3aGljaCBhcmUgZXhlbXB0IGZyb20gZGVwcyBhbGwgb3RoZXJzIG5lZWQgaXQuXHJcbiAgICAgICAgdGhyb3cgc3RhdGljRXJyb3IoJ1xcJ2RlcHNcXCcgcmVxdWlyZWQnLCBwcm92aWRlcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVwcztcclxufVxyXG4vKipcclxuICogQHBhcmFtIHs/fSB0ZXh0XHJcbiAqIEBwYXJhbSB7P30gb2JqXHJcbiAqIEByZXR1cm4gez99XHJcbiAqL1xyXG5mdW5jdGlvbiBzdGF0aWNFcnJvcih0ZXh0LCBvYmopIHtcclxuICAgIHJldHVybiBuZXcgRXJyb3IoZm9ybWF0RXJyb3IodGV4dCwgb2JqLCAnU3RhdGljSW5qZWN0b3JFcnJvcicpKTtcclxufVxyXG5leHBvcnQgeyDJtTAsIMm1MSB9O1xyIl19