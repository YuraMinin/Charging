/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as tslib_1 from "tslib";
import { Injectable, KeyValueDiffers, Pipe } from '@angular/core';
import * as ɵngcc0 from '@angular/core';
function makeKeyValuePair(key, value) {
    return { key: key, value: value };
}
/**
 * @ngModule CommonModule
 * @description
 *
 * Transforms Object or Map into an array of key value pairs.
 *
 * The output array will be ordered by keys.
 * By default the comparator will be by Unicode point value.
 * You can optionally pass a compareFn if your keys are complex types.
 *
 * @usageNotes
 * ### Examples
 *
 * This examples show how an Object or a Map can be iterated by ngFor with the use of this keyvalue
 * pipe.
 *
 * {@example common/pipes/ts/keyvalue_pipe.ts region='KeyValuePipe'}
 *
 * @publicApi
 */
var KeyValuePipe = /** @class */ (function () {
    function KeyValuePipe(differs) {
        this.differs = differs;
        this.keyValues = [];
    }
    KeyValuePipe.prototype.transform = function (input, compareFn) {
        var _this = this;
        if (compareFn === void 0) { compareFn = defaultComparator; }
        if (!input || (!(input instanceof Map) && typeof input !== 'object')) {
            return null;
        }
        if (!this.differ) {
            // make a differ for whatever type we've been passed in
            this.differ = this.differs.find(input).create();
        }
        var differChanges = this.differ.diff(input);
        if (differChanges) {
            this.keyValues = [];
            differChanges.forEachItem(function (r) {
                _this.keyValues.push(makeKeyValuePair(r.key, r.currentValue));
            });
            this.keyValues.sort(compareFn);
        }
        return this.keyValues;
    };
    KeyValuePipe = tslib_1.__decorate([
        tslib_1.__metadata("design:paramtypes", [KeyValueDiffers])
    ], KeyValuePipe);
KeyValuePipe.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: KeyValuePipe, factory: function KeyValuePipe_Factory(t) { return new (t || KeyValuePipe)(ɵngcc0.ɵɵinject(KeyValueDiffers)); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(KeyValuePipe, [{
        type: Injectable
    }, {
        type: Pipe,
        args: [{ name: 'keyvalue', pure: false }]
    }], function () { return [{ type: KeyValueDiffers }]; }, { differs: [], keyValues: [], transform: [], differ: [] });
KeyValuePipe.ngPipeDef = ɵngcc0.ɵɵdefinePipe({ name: "keyvalue", type: KeyValuePipe, factory: function KeyValuePipe_Factory(t) { return new (t || KeyValuePipe)(ɵngcc0.ɵɵdirectiveInject(KeyValueDiffers)); }, pure: false });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(KeyValuePipe, [{
        type: Injectable
    }, {
        type: Pipe,
        args: [{ name: 'keyvalue', pure: false }]
    }], function () { return [{ type: KeyValueDiffers }]; }, { differs: [], keyValues: [], transform: [], differ: [] });
    return KeyValuePipe;
}());
export { KeyValuePipe };
export function defaultComparator(keyValueA, keyValueB) {
    var a = keyValueA.key;
    var b = keyValueB.key;
    // if same exit with 0;
    if (a === b)
        return 0;
    // make sure that undefined are at the end of the sort.
    if (a === undefined)
        return 1;
    if (b === undefined)
        return -1;
    // make sure that nulls are at the end of the sort.
    if (a === null)
        return 1;
    if (b === null)
        return -1;
    if (typeof a == 'string' && typeof b == 'string') {
        return a < b ? -1 : 1;
    }
    if (typeof a == 'number' && typeof b == 'number') {
        return a - b;
    }
    if (typeof a == 'boolean' && typeof b == 'boolean') {
        return a < b ? -1 : 1;
    }
    // `a` and `b` are of different types. Compare their string values.
    var aString = String(a);
    var bString = String(b);
    return aString == bString ? 0 : aString < bString ? -1 : 1;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L1Byb2plY3RzL1Rlc3RQcm9qZWN0L0NoYXJnaW5nL0NoYXJnaW5nL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vZXNtNS9zcmMvcGlwZXMva2V5dmFsdWVfcGlwZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztBQVNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUNBZ0R1QyxBQUVTOzs7Ozs7Ozs7Ozs7Ozs7O3dIQUUzQiIsImZpbGUiOiJrZXl2YWx1ZV9waXBlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBLZXlWYWx1ZURpZmZlcnMsIFBpcGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuZnVuY3Rpb24gbWFrZUtleVZhbHVlUGFpcihrZXksIHZhbHVlKSB7XHJcbiAgICByZXR1cm4geyBrZXk6IGtleSwgdmFsdWU6IHZhbHVlIH07XHJcbn1cclxuLyoqXHJcbiAqIEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqXHJcbiAqIFRyYW5zZm9ybXMgT2JqZWN0IG9yIE1hcCBpbnRvIGFuIGFycmF5IG9mIGtleSB2YWx1ZSBwYWlycy5cclxuICpcclxuICogVGhlIG91dHB1dCBhcnJheSB3aWxsIGJlIG9yZGVyZWQgYnkga2V5cy5cclxuICogQnkgZGVmYXVsdCB0aGUgY29tcGFyYXRvciB3aWxsIGJlIGJ5IFVuaWNvZGUgcG9pbnQgdmFsdWUuXHJcbiAqIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIGEgY29tcGFyZUZuIGlmIHlvdXIga2V5cyBhcmUgY29tcGxleCB0eXBlcy5cclxuICpcclxuICogQHVzYWdlTm90ZXNcclxuICogIyMjIEV4YW1wbGVzXHJcbiAqXHJcbiAqIFRoaXMgZXhhbXBsZXMgc2hvdyBob3cgYW4gT2JqZWN0IG9yIGEgTWFwIGNhbiBiZSBpdGVyYXRlZCBieSBuZ0ZvciB3aXRoIHRoZSB1c2Ugb2YgdGhpcyBrZXl2YWx1ZVxyXG4gKiBwaXBlLlxyXG4gKlxyXG4gKiB7QGV4YW1wbGUgY29tbW9uL3BpcGVzL3RzL2tleXZhbHVlX3BpcGUudHMgcmVnaW9uPSdLZXlWYWx1ZVBpcGUnfVxyXG4gKlxyXG4gKiBAcHVibGljQXBpXHJcbiAqL1xyXG52YXIgS2V5VmFsdWVQaXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gS2V5VmFsdWVQaXBlKGRpZmZlcnMpIHtcclxuICAgICAgICB0aGlzLmRpZmZlcnMgPSBkaWZmZXJzO1xyXG4gICAgICAgIHRoaXMua2V5VmFsdWVzID0gW107XHJcbiAgICB9XHJcbiAgICBLZXlWYWx1ZVBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChpbnB1dCwgY29tcGFyZUZuKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoY29tcGFyZUZuID09PSB2b2lkIDApIHsgY29tcGFyZUZuID0gZGVmYXVsdENvbXBhcmF0b3I7IH1cclxuICAgICAgICBpZiAoIWlucHV0IHx8ICghKGlucHV0IGluc3RhbmNlb2YgTWFwKSAmJiB0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmRpZmZlcikge1xyXG4gICAgICAgICAgICAvLyBtYWtlIGEgZGlmZmVyIGZvciB3aGF0ZXZlciB0eXBlIHdlJ3ZlIGJlZW4gcGFzc2VkIGluXHJcbiAgICAgICAgICAgIHRoaXMuZGlmZmVyID0gdGhpcy5kaWZmZXJzLmZpbmQoaW5wdXQpLmNyZWF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGlmZmVyQ2hhbmdlcyA9IHRoaXMuZGlmZmVyLmRpZmYoaW5wdXQpO1xyXG4gICAgICAgIGlmIChkaWZmZXJDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMua2V5VmFsdWVzID0gW107XHJcbiAgICAgICAgICAgIGRpZmZlckNoYW5nZXMuZm9yRWFjaEl0ZW0oZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmtleVZhbHVlcy5wdXNoKG1ha2VLZXlWYWx1ZVBhaXIoci5rZXksIHIuY3VycmVudFZhbHVlKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmtleVZhbHVlcy5zb3J0KGNvbXBhcmVGbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmtleVZhbHVlcztcclxuICAgIH07XHJcbiAgICBLZXlWYWx1ZVBpcGUgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEluamVjdGFibGUoKSxcclxuICAgICAgICBQaXBlKHsgbmFtZTogJ2tleXZhbHVlJywgcHVyZTogZmFsc2UgfSksXHJcbiAgICAgICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0tleVZhbHVlRGlmZmVyc10pXHJcbiAgICBdLCBLZXlWYWx1ZVBpcGUpO1xyXG4gICAgcmV0dXJuIEtleVZhbHVlUGlwZTtcclxufSgpKTtcclxuZXhwb3J0IHsgS2V5VmFsdWVQaXBlIH07XHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0Q29tcGFyYXRvcihrZXlWYWx1ZUEsIGtleVZhbHVlQikge1xyXG4gICAgdmFyIGEgPSBrZXlWYWx1ZUEua2V5O1xyXG4gICAgdmFyIGIgPSBrZXlWYWx1ZUIua2V5O1xyXG4gICAgLy8gaWYgc2FtZSBleGl0IHdpdGggMDtcclxuICAgIGlmIChhID09PSBiKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgdW5kZWZpbmVkIGFyZSBhdCB0aGUgZW5kIG9mIHRoZSBzb3J0LlxyXG4gICAgaWYgKGEgPT09IHVuZGVmaW5lZClcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIGlmIChiID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgbnVsbHMgYXJlIGF0IHRoZSBlbmQgb2YgdGhlIHNvcnQuXHJcbiAgICBpZiAoYSA9PT0gbnVsbClcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIGlmIChiID09PSBudWxsKVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIGlmICh0eXBlb2YgYSA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgYiA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogMTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgYSA9PSAnbnVtYmVyJyAmJiB0eXBlb2YgYiA9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHJldHVybiBhIC0gYjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgYSA9PSAnYm9vbGVhbicgJiYgdHlwZW9mIGIgPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiAxO1xyXG4gICAgfVxyXG4gICAgLy8gYGFgIGFuZCBgYmAgYXJlIG9mIGRpZmZlcmVudCB0eXBlcy4gQ29tcGFyZSB0aGVpciBzdHJpbmcgdmFsdWVzLlxyXG4gICAgdmFyIGFTdHJpbmcgPSBTdHJpbmcoYSk7XHJcbiAgICB2YXIgYlN0cmluZyA9IFN0cmluZyhiKTtcclxuICAgIHJldHVybiBhU3RyaW5nID09IGJTdHJpbmcgPyAwIDogYVN0cmluZyA8IGJTdHJpbmcgPyAtMSA6IDE7XHJcbn1cciJdfQ==